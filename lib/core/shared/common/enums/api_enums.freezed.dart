// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'api_enums.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AutoPayOptionType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() fixedAmount,
    required TResult Function() fullAmount,
    required TResult Function() fullAmountNotToExceed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? fixedAmount,
    TResult? Function()? fullAmount,
    TResult? Function()? fullAmountNotToExceed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? fixedAmount,
    TResult Function()? fullAmount,
    TResult Function()? fullAmountNotToExceed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_FixedAmount value) fixedAmount,
    required TResult Function(_FullAmount value) fullAmount,
    required TResult Function(_FullAmountNotToExceed value)
        fullAmountNotToExceed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_FixedAmount value)? fixedAmount,
    TResult? Function(_FullAmount value)? fullAmount,
    TResult? Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_FixedAmount value)? fixedAmount,
    TResult Function(_FullAmount value)? fullAmount,
    TResult Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AutoPayOptionTypeCopyWith<$Res> {
  factory $AutoPayOptionTypeCopyWith(
          AutoPayOptionType value, $Res Function(AutoPayOptionType) then) =
      _$AutoPayOptionTypeCopyWithImpl<$Res, AutoPayOptionType>;
}

/// @nodoc
class _$AutoPayOptionTypeCopyWithImpl<$Res, $Val extends AutoPayOptionType>
    implements $AutoPayOptionTypeCopyWith<$Res> {
  _$AutoPayOptionTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AutoPayOptionType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$NoneImplCopyWith<$Res> {
  factory _$$NoneImplCopyWith(
          _$NoneImpl value, $Res Function(_$NoneImpl) then) =
      __$$NoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoneImplCopyWithImpl<$Res>
    extends _$AutoPayOptionTypeCopyWithImpl<$Res, _$NoneImpl>
    implements _$$NoneImplCopyWith<$Res> {
  __$$NoneImplCopyWithImpl(_$NoneImpl _value, $Res Function(_$NoneImpl) _then)
      : super(_value, _then);

  /// Create a copy of AutoPayOptionType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$NoneImpl implements _None {
  const _$NoneImpl();

  @override
  String toString() {
    return 'AutoPayOptionType.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() fixedAmount,
    required TResult Function() fullAmount,
    required TResult Function() fullAmountNotToExceed,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? fixedAmount,
    TResult? Function()? fullAmount,
    TResult? Function()? fullAmountNotToExceed,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? fixedAmount,
    TResult Function()? fullAmount,
    TResult Function()? fullAmountNotToExceed,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_FixedAmount value) fixedAmount,
    required TResult Function(_FullAmount value) fullAmount,
    required TResult Function(_FullAmountNotToExceed value)
        fullAmountNotToExceed,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_FixedAmount value)? fixedAmount,
    TResult? Function(_FullAmount value)? fullAmount,
    TResult? Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_FixedAmount value)? fixedAmount,
    TResult Function(_FullAmount value)? fullAmount,
    TResult Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class _None implements AutoPayOptionType {
  const factory _None() = _$NoneImpl;
}

/// @nodoc
abstract class _$$FixedAmountImplCopyWith<$Res> {
  factory _$$FixedAmountImplCopyWith(
          _$FixedAmountImpl value, $Res Function(_$FixedAmountImpl) then) =
      __$$FixedAmountImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FixedAmountImplCopyWithImpl<$Res>
    extends _$AutoPayOptionTypeCopyWithImpl<$Res, _$FixedAmountImpl>
    implements _$$FixedAmountImplCopyWith<$Res> {
  __$$FixedAmountImplCopyWithImpl(
      _$FixedAmountImpl _value, $Res Function(_$FixedAmountImpl) _then)
      : super(_value, _then);

  /// Create a copy of AutoPayOptionType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FixedAmountImpl implements _FixedAmount {
  const _$FixedAmountImpl();

  @override
  String toString() {
    return 'AutoPayOptionType.fixedAmount()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FixedAmountImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() fixedAmount,
    required TResult Function() fullAmount,
    required TResult Function() fullAmountNotToExceed,
  }) {
    return fixedAmount();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? fixedAmount,
    TResult? Function()? fullAmount,
    TResult? Function()? fullAmountNotToExceed,
  }) {
    return fixedAmount?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? fixedAmount,
    TResult Function()? fullAmount,
    TResult Function()? fullAmountNotToExceed,
    required TResult orElse(),
  }) {
    if (fixedAmount != null) {
      return fixedAmount();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_FixedAmount value) fixedAmount,
    required TResult Function(_FullAmount value) fullAmount,
    required TResult Function(_FullAmountNotToExceed value)
        fullAmountNotToExceed,
  }) {
    return fixedAmount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_FixedAmount value)? fixedAmount,
    TResult? Function(_FullAmount value)? fullAmount,
    TResult? Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
  }) {
    return fixedAmount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_FixedAmount value)? fixedAmount,
    TResult Function(_FullAmount value)? fullAmount,
    TResult Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
    required TResult orElse(),
  }) {
    if (fixedAmount != null) {
      return fixedAmount(this);
    }
    return orElse();
  }
}

abstract class _FixedAmount implements AutoPayOptionType {
  const factory _FixedAmount() = _$FixedAmountImpl;
}

/// @nodoc
abstract class _$$FullAmountImplCopyWith<$Res> {
  factory _$$FullAmountImplCopyWith(
          _$FullAmountImpl value, $Res Function(_$FullAmountImpl) then) =
      __$$FullAmountImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FullAmountImplCopyWithImpl<$Res>
    extends _$AutoPayOptionTypeCopyWithImpl<$Res, _$FullAmountImpl>
    implements _$$FullAmountImplCopyWith<$Res> {
  __$$FullAmountImplCopyWithImpl(
      _$FullAmountImpl _value, $Res Function(_$FullAmountImpl) _then)
      : super(_value, _then);

  /// Create a copy of AutoPayOptionType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FullAmountImpl implements _FullAmount {
  const _$FullAmountImpl();

  @override
  String toString() {
    return 'AutoPayOptionType.fullAmount()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FullAmountImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() fixedAmount,
    required TResult Function() fullAmount,
    required TResult Function() fullAmountNotToExceed,
  }) {
    return fullAmount();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? fixedAmount,
    TResult? Function()? fullAmount,
    TResult? Function()? fullAmountNotToExceed,
  }) {
    return fullAmount?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? fixedAmount,
    TResult Function()? fullAmount,
    TResult Function()? fullAmountNotToExceed,
    required TResult orElse(),
  }) {
    if (fullAmount != null) {
      return fullAmount();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_FixedAmount value) fixedAmount,
    required TResult Function(_FullAmount value) fullAmount,
    required TResult Function(_FullAmountNotToExceed value)
        fullAmountNotToExceed,
  }) {
    return fullAmount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_FixedAmount value)? fixedAmount,
    TResult? Function(_FullAmount value)? fullAmount,
    TResult? Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
  }) {
    return fullAmount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_FixedAmount value)? fixedAmount,
    TResult Function(_FullAmount value)? fullAmount,
    TResult Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
    required TResult orElse(),
  }) {
    if (fullAmount != null) {
      return fullAmount(this);
    }
    return orElse();
  }
}

abstract class _FullAmount implements AutoPayOptionType {
  const factory _FullAmount() = _$FullAmountImpl;
}

/// @nodoc
abstract class _$$FullAmountNotToExceedImplCopyWith<$Res> {
  factory _$$FullAmountNotToExceedImplCopyWith(
          _$FullAmountNotToExceedImpl value,
          $Res Function(_$FullAmountNotToExceedImpl) then) =
      __$$FullAmountNotToExceedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FullAmountNotToExceedImplCopyWithImpl<$Res>
    extends _$AutoPayOptionTypeCopyWithImpl<$Res, _$FullAmountNotToExceedImpl>
    implements _$$FullAmountNotToExceedImplCopyWith<$Res> {
  __$$FullAmountNotToExceedImplCopyWithImpl(_$FullAmountNotToExceedImpl _value,
      $Res Function(_$FullAmountNotToExceedImpl) _then)
      : super(_value, _then);

  /// Create a copy of AutoPayOptionType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FullAmountNotToExceedImpl implements _FullAmountNotToExceed {
  const _$FullAmountNotToExceedImpl();

  @override
  String toString() {
    return 'AutoPayOptionType.fullAmountNotToExceed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FullAmountNotToExceedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() fixedAmount,
    required TResult Function() fullAmount,
    required TResult Function() fullAmountNotToExceed,
  }) {
    return fullAmountNotToExceed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? fixedAmount,
    TResult? Function()? fullAmount,
    TResult? Function()? fullAmountNotToExceed,
  }) {
    return fullAmountNotToExceed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? fixedAmount,
    TResult Function()? fullAmount,
    TResult Function()? fullAmountNotToExceed,
    required TResult orElse(),
  }) {
    if (fullAmountNotToExceed != null) {
      return fullAmountNotToExceed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_FixedAmount value) fixedAmount,
    required TResult Function(_FullAmount value) fullAmount,
    required TResult Function(_FullAmountNotToExceed value)
        fullAmountNotToExceed,
  }) {
    return fullAmountNotToExceed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_None value)? none,
    TResult? Function(_FixedAmount value)? fixedAmount,
    TResult? Function(_FullAmount value)? fullAmount,
    TResult? Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
  }) {
    return fullAmountNotToExceed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_FixedAmount value)? fixedAmount,
    TResult Function(_FullAmount value)? fullAmount,
    TResult Function(_FullAmountNotToExceed value)? fullAmountNotToExceed,
    required TResult orElse(),
  }) {
    if (fullAmountNotToExceed != null) {
      return fullAmountNotToExceed(this);
    }
    return orElse();
  }
}

abstract class _FullAmountNotToExceed implements AutoPayOptionType {
  const factory _FullAmountNotToExceed() = _$FullAmountNotToExceedImpl;
}

/// @nodoc
mixin _$BillingSettingDeliveryType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mail,
    required TResult Function() email,
    required TResult Function() textMessage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mail,
    TResult? Function()? email,
    TResult? Function()? textMessage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mail,
    TResult Function()? email,
    TResult Function()? textMessage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Mail value) mail,
    required TResult Function(_Email value) email,
    required TResult Function(_TextMessage value) textMessage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Mail value)? mail,
    TResult? Function(_Email value)? email,
    TResult? Function(_TextMessage value)? textMessage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Mail value)? mail,
    TResult Function(_Email value)? email,
    TResult Function(_TextMessage value)? textMessage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BillingSettingDeliveryTypeCopyWith<$Res> {
  factory $BillingSettingDeliveryTypeCopyWith(BillingSettingDeliveryType value,
          $Res Function(BillingSettingDeliveryType) then) =
      _$BillingSettingDeliveryTypeCopyWithImpl<$Res,
          BillingSettingDeliveryType>;
}

/// @nodoc
class _$BillingSettingDeliveryTypeCopyWithImpl<$Res,
        $Val extends BillingSettingDeliveryType>
    implements $BillingSettingDeliveryTypeCopyWith<$Res> {
  _$BillingSettingDeliveryTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BillingSettingDeliveryType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$MailImplCopyWith<$Res> {
  factory _$$MailImplCopyWith(
          _$MailImpl value, $Res Function(_$MailImpl) then) =
      __$$MailImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MailImplCopyWithImpl<$Res>
    extends _$BillingSettingDeliveryTypeCopyWithImpl<$Res, _$MailImpl>
    implements _$$MailImplCopyWith<$Res> {
  __$$MailImplCopyWithImpl(_$MailImpl _value, $Res Function(_$MailImpl) _then)
      : super(_value, _then);

  /// Create a copy of BillingSettingDeliveryType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$MailImpl implements _Mail {
  const _$MailImpl();

  @override
  String toString() {
    return 'BillingSettingDeliveryType.mail()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MailImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mail,
    required TResult Function() email,
    required TResult Function() textMessage,
  }) {
    return mail();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mail,
    TResult? Function()? email,
    TResult? Function()? textMessage,
  }) {
    return mail?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mail,
    TResult Function()? email,
    TResult Function()? textMessage,
    required TResult orElse(),
  }) {
    if (mail != null) {
      return mail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Mail value) mail,
    required TResult Function(_Email value) email,
    required TResult Function(_TextMessage value) textMessage,
  }) {
    return mail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Mail value)? mail,
    TResult? Function(_Email value)? email,
    TResult? Function(_TextMessage value)? textMessage,
  }) {
    return mail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Mail value)? mail,
    TResult Function(_Email value)? email,
    TResult Function(_TextMessage value)? textMessage,
    required TResult orElse(),
  }) {
    if (mail != null) {
      return mail(this);
    }
    return orElse();
  }
}

abstract class _Mail implements BillingSettingDeliveryType {
  const factory _Mail() = _$MailImpl;
}

/// @nodoc
abstract class _$$EmailImplCopyWith<$Res> {
  factory _$$EmailImplCopyWith(
          _$EmailImpl value, $Res Function(_$EmailImpl) then) =
      __$$EmailImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailImplCopyWithImpl<$Res>
    extends _$BillingSettingDeliveryTypeCopyWithImpl<$Res, _$EmailImpl>
    implements _$$EmailImplCopyWith<$Res> {
  __$$EmailImplCopyWithImpl(
      _$EmailImpl _value, $Res Function(_$EmailImpl) _then)
      : super(_value, _then);

  /// Create a copy of BillingSettingDeliveryType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EmailImpl implements _Email {
  const _$EmailImpl();

  @override
  String toString() {
    return 'BillingSettingDeliveryType.email()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmailImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mail,
    required TResult Function() email,
    required TResult Function() textMessage,
  }) {
    return email();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mail,
    TResult? Function()? email,
    TResult? Function()? textMessage,
  }) {
    return email?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mail,
    TResult Function()? email,
    TResult Function()? textMessage,
    required TResult orElse(),
  }) {
    if (email != null) {
      return email();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Mail value) mail,
    required TResult Function(_Email value) email,
    required TResult Function(_TextMessage value) textMessage,
  }) {
    return email(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Mail value)? mail,
    TResult? Function(_Email value)? email,
    TResult? Function(_TextMessage value)? textMessage,
  }) {
    return email?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Mail value)? mail,
    TResult Function(_Email value)? email,
    TResult Function(_TextMessage value)? textMessage,
    required TResult orElse(),
  }) {
    if (email != null) {
      return email(this);
    }
    return orElse();
  }
}

abstract class _Email implements BillingSettingDeliveryType {
  const factory _Email() = _$EmailImpl;
}

/// @nodoc
abstract class _$$TextMessageImplCopyWith<$Res> {
  factory _$$TextMessageImplCopyWith(
          _$TextMessageImpl value, $Res Function(_$TextMessageImpl) then) =
      __$$TextMessageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TextMessageImplCopyWithImpl<$Res>
    extends _$BillingSettingDeliveryTypeCopyWithImpl<$Res, _$TextMessageImpl>
    implements _$$TextMessageImplCopyWith<$Res> {
  __$$TextMessageImplCopyWithImpl(
      _$TextMessageImpl _value, $Res Function(_$TextMessageImpl) _then)
      : super(_value, _then);

  /// Create a copy of BillingSettingDeliveryType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$TextMessageImpl implements _TextMessage {
  const _$TextMessageImpl();

  @override
  String toString() {
    return 'BillingSettingDeliveryType.textMessage()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TextMessageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mail,
    required TResult Function() email,
    required TResult Function() textMessage,
  }) {
    return textMessage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mail,
    TResult? Function()? email,
    TResult? Function()? textMessage,
  }) {
    return textMessage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mail,
    TResult Function()? email,
    TResult Function()? textMessage,
    required TResult orElse(),
  }) {
    if (textMessage != null) {
      return textMessage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Mail value) mail,
    required TResult Function(_Email value) email,
    required TResult Function(_TextMessage value) textMessage,
  }) {
    return textMessage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Mail value)? mail,
    TResult? Function(_Email value)? email,
    TResult? Function(_TextMessage value)? textMessage,
  }) {
    return textMessage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Mail value)? mail,
    TResult Function(_Email value)? email,
    TResult Function(_TextMessage value)? textMessage,
    required TResult orElse(),
  }) {
    if (textMessage != null) {
      return textMessage(this);
    }
    return orElse();
  }
}

abstract class _TextMessage implements BillingSettingDeliveryType {
  const factory _TextMessage() = _$TextMessageImpl;
}

/// @nodoc
mixin _$ContentType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() oneTimePaymentAuthorizationText,
    required TResult Function() autoPayAuthorizationText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? oneTimePaymentAuthorizationText,
    TResult? Function()? autoPayAuthorizationText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? oneTimePaymentAuthorizationText,
    TResult Function()? autoPayAuthorizationText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownContentType value) unknown,
    required TResult Function(_OneTimePaymentAuthorizationText value)
        oneTimePaymentAuthorizationText,
    required TResult Function(_AutoPayAuthorizationText value)
        autoPayAuthorizationText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownContentType value)? unknown,
    TResult? Function(_OneTimePaymentAuthorizationText value)?
        oneTimePaymentAuthorizationText,
    TResult? Function(_AutoPayAuthorizationText value)?
        autoPayAuthorizationText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownContentType value)? unknown,
    TResult Function(_OneTimePaymentAuthorizationText value)?
        oneTimePaymentAuthorizationText,
    TResult Function(_AutoPayAuthorizationText value)? autoPayAuthorizationText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContentTypeCopyWith<$Res> {
  factory $ContentTypeCopyWith(
          ContentType value, $Res Function(ContentType) then) =
      _$ContentTypeCopyWithImpl<$Res, ContentType>;
}

/// @nodoc
class _$ContentTypeCopyWithImpl<$Res, $Val extends ContentType>
    implements $ContentTypeCopyWith<$Res> {
  _$ContentTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ContentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$UnknownContentTypeImplCopyWith<$Res> {
  factory _$$UnknownContentTypeImplCopyWith(_$UnknownContentTypeImpl value,
          $Res Function(_$UnknownContentTypeImpl) then) =
      __$$UnknownContentTypeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownContentTypeImplCopyWithImpl<$Res>
    extends _$ContentTypeCopyWithImpl<$Res, _$UnknownContentTypeImpl>
    implements _$$UnknownContentTypeImplCopyWith<$Res> {
  __$$UnknownContentTypeImplCopyWithImpl(_$UnknownContentTypeImpl _value,
      $Res Function(_$UnknownContentTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of ContentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UnknownContentTypeImpl implements _UnknownContentType {
  const _$UnknownContentTypeImpl();

  @override
  String toString() {
    return 'ContentType.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnknownContentTypeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() oneTimePaymentAuthorizationText,
    required TResult Function() autoPayAuthorizationText,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? oneTimePaymentAuthorizationText,
    TResult? Function()? autoPayAuthorizationText,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? oneTimePaymentAuthorizationText,
    TResult Function()? autoPayAuthorizationText,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownContentType value) unknown,
    required TResult Function(_OneTimePaymentAuthorizationText value)
        oneTimePaymentAuthorizationText,
    required TResult Function(_AutoPayAuthorizationText value)
        autoPayAuthorizationText,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownContentType value)? unknown,
    TResult? Function(_OneTimePaymentAuthorizationText value)?
        oneTimePaymentAuthorizationText,
    TResult? Function(_AutoPayAuthorizationText value)?
        autoPayAuthorizationText,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownContentType value)? unknown,
    TResult Function(_OneTimePaymentAuthorizationText value)?
        oneTimePaymentAuthorizationText,
    TResult Function(_AutoPayAuthorizationText value)? autoPayAuthorizationText,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class _UnknownContentType implements ContentType {
  const factory _UnknownContentType() = _$UnknownContentTypeImpl;
}

/// @nodoc
abstract class _$$OneTimePaymentAuthorizationTextImplCopyWith<$Res> {
  factory _$$OneTimePaymentAuthorizationTextImplCopyWith(
          _$OneTimePaymentAuthorizationTextImpl value,
          $Res Function(_$OneTimePaymentAuthorizationTextImpl) then) =
      __$$OneTimePaymentAuthorizationTextImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OneTimePaymentAuthorizationTextImplCopyWithImpl<$Res>
    extends _$ContentTypeCopyWithImpl<$Res,
        _$OneTimePaymentAuthorizationTextImpl>
    implements _$$OneTimePaymentAuthorizationTextImplCopyWith<$Res> {
  __$$OneTimePaymentAuthorizationTextImplCopyWithImpl(
      _$OneTimePaymentAuthorizationTextImpl _value,
      $Res Function(_$OneTimePaymentAuthorizationTextImpl) _then)
      : super(_value, _then);

  /// Create a copy of ContentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$OneTimePaymentAuthorizationTextImpl
    implements _OneTimePaymentAuthorizationText {
  const _$OneTimePaymentAuthorizationTextImpl();

  @override
  String toString() {
    return 'ContentType.oneTimePaymentAuthorizationText()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OneTimePaymentAuthorizationTextImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() oneTimePaymentAuthorizationText,
    required TResult Function() autoPayAuthorizationText,
  }) {
    return oneTimePaymentAuthorizationText();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? oneTimePaymentAuthorizationText,
    TResult? Function()? autoPayAuthorizationText,
  }) {
    return oneTimePaymentAuthorizationText?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? oneTimePaymentAuthorizationText,
    TResult Function()? autoPayAuthorizationText,
    required TResult orElse(),
  }) {
    if (oneTimePaymentAuthorizationText != null) {
      return oneTimePaymentAuthorizationText();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownContentType value) unknown,
    required TResult Function(_OneTimePaymentAuthorizationText value)
        oneTimePaymentAuthorizationText,
    required TResult Function(_AutoPayAuthorizationText value)
        autoPayAuthorizationText,
  }) {
    return oneTimePaymentAuthorizationText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownContentType value)? unknown,
    TResult? Function(_OneTimePaymentAuthorizationText value)?
        oneTimePaymentAuthorizationText,
    TResult? Function(_AutoPayAuthorizationText value)?
        autoPayAuthorizationText,
  }) {
    return oneTimePaymentAuthorizationText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownContentType value)? unknown,
    TResult Function(_OneTimePaymentAuthorizationText value)?
        oneTimePaymentAuthorizationText,
    TResult Function(_AutoPayAuthorizationText value)? autoPayAuthorizationText,
    required TResult orElse(),
  }) {
    if (oneTimePaymentAuthorizationText != null) {
      return oneTimePaymentAuthorizationText(this);
    }
    return orElse();
  }
}

abstract class _OneTimePaymentAuthorizationText implements ContentType {
  const factory _OneTimePaymentAuthorizationText() =
      _$OneTimePaymentAuthorizationTextImpl;
}

/// @nodoc
abstract class _$$AutoPayAuthorizationTextImplCopyWith<$Res> {
  factory _$$AutoPayAuthorizationTextImplCopyWith(
          _$AutoPayAuthorizationTextImpl value,
          $Res Function(_$AutoPayAuthorizationTextImpl) then) =
      __$$AutoPayAuthorizationTextImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AutoPayAuthorizationTextImplCopyWithImpl<$Res>
    extends _$ContentTypeCopyWithImpl<$Res, _$AutoPayAuthorizationTextImpl>
    implements _$$AutoPayAuthorizationTextImplCopyWith<$Res> {
  __$$AutoPayAuthorizationTextImplCopyWithImpl(
      _$AutoPayAuthorizationTextImpl _value,
      $Res Function(_$AutoPayAuthorizationTextImpl) _then)
      : super(_value, _then);

  /// Create a copy of ContentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AutoPayAuthorizationTextImpl implements _AutoPayAuthorizationText {
  const _$AutoPayAuthorizationTextImpl();

  @override
  String toString() {
    return 'ContentType.autoPayAuthorizationText()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AutoPayAuthorizationTextImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() oneTimePaymentAuthorizationText,
    required TResult Function() autoPayAuthorizationText,
  }) {
    return autoPayAuthorizationText();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? oneTimePaymentAuthorizationText,
    TResult? Function()? autoPayAuthorizationText,
  }) {
    return autoPayAuthorizationText?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? oneTimePaymentAuthorizationText,
    TResult Function()? autoPayAuthorizationText,
    required TResult orElse(),
  }) {
    if (autoPayAuthorizationText != null) {
      return autoPayAuthorizationText();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownContentType value) unknown,
    required TResult Function(_OneTimePaymentAuthorizationText value)
        oneTimePaymentAuthorizationText,
    required TResult Function(_AutoPayAuthorizationText value)
        autoPayAuthorizationText,
  }) {
    return autoPayAuthorizationText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownContentType value)? unknown,
    TResult? Function(_OneTimePaymentAuthorizationText value)?
        oneTimePaymentAuthorizationText,
    TResult? Function(_AutoPayAuthorizationText value)?
        autoPayAuthorizationText,
  }) {
    return autoPayAuthorizationText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownContentType value)? unknown,
    TResult Function(_OneTimePaymentAuthorizationText value)?
        oneTimePaymentAuthorizationText,
    TResult Function(_AutoPayAuthorizationText value)? autoPayAuthorizationText,
    required TResult orElse(),
  }) {
    if (autoPayAuthorizationText != null) {
      return autoPayAuthorizationText(this);
    }
    return orElse();
  }
}

abstract class _AutoPayAuthorizationText implements ContentType {
  const factory _AutoPayAuthorizationText() = _$AutoPayAuthorizationTextImpl;
}

/// @nodoc
mixin _$LoanApplicationType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() homeLoan,
    required TResult Function() rentToOwn,
    required TResult Function() leaseOption,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? homeLoan,
    TResult? Function()? rentToOwn,
    TResult? Function()? leaseOption,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? homeLoan,
    TResult Function()? rentToOwn,
    TResult Function()? leaseOption,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HomeLoan value) homeLoan,
    required TResult Function(_RentToOwn value) rentToOwn,
    required TResult Function(_LeaseOption value) leaseOption,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HomeLoan value)? homeLoan,
    TResult? Function(_RentToOwn value)? rentToOwn,
    TResult? Function(_LeaseOption value)? leaseOption,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HomeLoan value)? homeLoan,
    TResult Function(_RentToOwn value)? rentToOwn,
    TResult Function(_LeaseOption value)? leaseOption,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoanApplicationTypeCopyWith<$Res> {
  factory $LoanApplicationTypeCopyWith(
          LoanApplicationType value, $Res Function(LoanApplicationType) then) =
      _$LoanApplicationTypeCopyWithImpl<$Res, LoanApplicationType>;
}

/// @nodoc
class _$LoanApplicationTypeCopyWithImpl<$Res, $Val extends LoanApplicationType>
    implements $LoanApplicationTypeCopyWith<$Res> {
  _$LoanApplicationTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LoanApplicationType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$HomeLoanImplCopyWith<$Res> {
  factory _$$HomeLoanImplCopyWith(
          _$HomeLoanImpl value, $Res Function(_$HomeLoanImpl) then) =
      __$$HomeLoanImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HomeLoanImplCopyWithImpl<$Res>
    extends _$LoanApplicationTypeCopyWithImpl<$Res, _$HomeLoanImpl>
    implements _$$HomeLoanImplCopyWith<$Res> {
  __$$HomeLoanImplCopyWithImpl(
      _$HomeLoanImpl _value, $Res Function(_$HomeLoanImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoanApplicationType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$HomeLoanImpl implements _HomeLoan {
  const _$HomeLoanImpl();

  @override
  String toString() {
    return 'LoanApplicationType.homeLoan()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HomeLoanImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() homeLoan,
    required TResult Function() rentToOwn,
    required TResult Function() leaseOption,
  }) {
    return homeLoan();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? homeLoan,
    TResult? Function()? rentToOwn,
    TResult? Function()? leaseOption,
  }) {
    return homeLoan?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? homeLoan,
    TResult Function()? rentToOwn,
    TResult Function()? leaseOption,
    required TResult orElse(),
  }) {
    if (homeLoan != null) {
      return homeLoan();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HomeLoan value) homeLoan,
    required TResult Function(_RentToOwn value) rentToOwn,
    required TResult Function(_LeaseOption value) leaseOption,
  }) {
    return homeLoan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HomeLoan value)? homeLoan,
    TResult? Function(_RentToOwn value)? rentToOwn,
    TResult? Function(_LeaseOption value)? leaseOption,
  }) {
    return homeLoan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HomeLoan value)? homeLoan,
    TResult Function(_RentToOwn value)? rentToOwn,
    TResult Function(_LeaseOption value)? leaseOption,
    required TResult orElse(),
  }) {
    if (homeLoan != null) {
      return homeLoan(this);
    }
    return orElse();
  }
}

abstract class _HomeLoan implements LoanApplicationType {
  const factory _HomeLoan() = _$HomeLoanImpl;
}

/// @nodoc
abstract class _$$RentToOwnImplCopyWith<$Res> {
  factory _$$RentToOwnImplCopyWith(
          _$RentToOwnImpl value, $Res Function(_$RentToOwnImpl) then) =
      __$$RentToOwnImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RentToOwnImplCopyWithImpl<$Res>
    extends _$LoanApplicationTypeCopyWithImpl<$Res, _$RentToOwnImpl>
    implements _$$RentToOwnImplCopyWith<$Res> {
  __$$RentToOwnImplCopyWithImpl(
      _$RentToOwnImpl _value, $Res Function(_$RentToOwnImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoanApplicationType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RentToOwnImpl implements _RentToOwn {
  const _$RentToOwnImpl();

  @override
  String toString() {
    return 'LoanApplicationType.rentToOwn()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RentToOwnImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() homeLoan,
    required TResult Function() rentToOwn,
    required TResult Function() leaseOption,
  }) {
    return rentToOwn();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? homeLoan,
    TResult? Function()? rentToOwn,
    TResult? Function()? leaseOption,
  }) {
    return rentToOwn?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? homeLoan,
    TResult Function()? rentToOwn,
    TResult Function()? leaseOption,
    required TResult orElse(),
  }) {
    if (rentToOwn != null) {
      return rentToOwn();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HomeLoan value) homeLoan,
    required TResult Function(_RentToOwn value) rentToOwn,
    required TResult Function(_LeaseOption value) leaseOption,
  }) {
    return rentToOwn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HomeLoan value)? homeLoan,
    TResult? Function(_RentToOwn value)? rentToOwn,
    TResult? Function(_LeaseOption value)? leaseOption,
  }) {
    return rentToOwn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HomeLoan value)? homeLoan,
    TResult Function(_RentToOwn value)? rentToOwn,
    TResult Function(_LeaseOption value)? leaseOption,
    required TResult orElse(),
  }) {
    if (rentToOwn != null) {
      return rentToOwn(this);
    }
    return orElse();
  }
}

abstract class _RentToOwn implements LoanApplicationType {
  const factory _RentToOwn() = _$RentToOwnImpl;
}

/// @nodoc
abstract class _$$LeaseOptionImplCopyWith<$Res> {
  factory _$$LeaseOptionImplCopyWith(
          _$LeaseOptionImpl value, $Res Function(_$LeaseOptionImpl) then) =
      __$$LeaseOptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LeaseOptionImplCopyWithImpl<$Res>
    extends _$LoanApplicationTypeCopyWithImpl<$Res, _$LeaseOptionImpl>
    implements _$$LeaseOptionImplCopyWith<$Res> {
  __$$LeaseOptionImplCopyWithImpl(
      _$LeaseOptionImpl _value, $Res Function(_$LeaseOptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoanApplicationType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LeaseOptionImpl implements _LeaseOption {
  const _$LeaseOptionImpl();

  @override
  String toString() {
    return 'LoanApplicationType.leaseOption()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LeaseOptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() homeLoan,
    required TResult Function() rentToOwn,
    required TResult Function() leaseOption,
  }) {
    return leaseOption();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? homeLoan,
    TResult? Function()? rentToOwn,
    TResult? Function()? leaseOption,
  }) {
    return leaseOption?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? homeLoan,
    TResult Function()? rentToOwn,
    TResult Function()? leaseOption,
    required TResult orElse(),
  }) {
    if (leaseOption != null) {
      return leaseOption();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HomeLoan value) homeLoan,
    required TResult Function(_RentToOwn value) rentToOwn,
    required TResult Function(_LeaseOption value) leaseOption,
  }) {
    return leaseOption(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HomeLoan value)? homeLoan,
    TResult? Function(_RentToOwn value)? rentToOwn,
    TResult? Function(_LeaseOption value)? leaseOption,
  }) {
    return leaseOption?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HomeLoan value)? homeLoan,
    TResult Function(_RentToOwn value)? rentToOwn,
    TResult Function(_LeaseOption value)? leaseOption,
    required TResult orElse(),
  }) {
    if (leaseOption != null) {
      return leaseOption(this);
    }
    return orElse();
  }
}

abstract class _LeaseOption implements LoanApplicationType {
  const factory _LeaseOption() = _$LeaseOptionImpl;
}

/// @nodoc
mixin _$LegalDocumentType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() termsOfService,
    required TResult Function() privacyPolicy,
    required TResult Function() supportedBrowsersAndOperatingSystems,
    required TResult Function() unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? termsOfService,
    TResult? Function()? privacyPolicy,
    TResult? Function()? supportedBrowsersAndOperatingSystems,
    TResult? Function()? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? termsOfService,
    TResult Function()? privacyPolicy,
    TResult Function()? supportedBrowsersAndOperatingSystems,
    TResult Function()? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TermsOfService value) termsOfService,
    required TResult Function(_PrivacyPolicy value) privacyPolicy,
    required TResult Function(_SupportedBrowsers value)
        supportedBrowsersAndOperatingSystems,
    required TResult Function(_Unknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TermsOfService value)? termsOfService,
    TResult? Function(_PrivacyPolicy value)? privacyPolicy,
    TResult? Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult? Function(_Unknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TermsOfService value)? termsOfService,
    TResult Function(_PrivacyPolicy value)? privacyPolicy,
    TResult Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult Function(_Unknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LegalDocumentTypeCopyWith<$Res> {
  factory $LegalDocumentTypeCopyWith(
          LegalDocumentType value, $Res Function(LegalDocumentType) then) =
      _$LegalDocumentTypeCopyWithImpl<$Res, LegalDocumentType>;
}

/// @nodoc
class _$LegalDocumentTypeCopyWithImpl<$Res, $Val extends LegalDocumentType>
    implements $LegalDocumentTypeCopyWith<$Res> {
  _$LegalDocumentTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LegalDocumentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$TermsOfServiceImplCopyWith<$Res> {
  factory _$$TermsOfServiceImplCopyWith(_$TermsOfServiceImpl value,
          $Res Function(_$TermsOfServiceImpl) then) =
      __$$TermsOfServiceImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TermsOfServiceImplCopyWithImpl<$Res>
    extends _$LegalDocumentTypeCopyWithImpl<$Res, _$TermsOfServiceImpl>
    implements _$$TermsOfServiceImplCopyWith<$Res> {
  __$$TermsOfServiceImplCopyWithImpl(
      _$TermsOfServiceImpl _value, $Res Function(_$TermsOfServiceImpl) _then)
      : super(_value, _then);

  /// Create a copy of LegalDocumentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$TermsOfServiceImpl implements _TermsOfService {
  const _$TermsOfServiceImpl();

  @override
  String toString() {
    return 'LegalDocumentType.termsOfService()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TermsOfServiceImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() termsOfService,
    required TResult Function() privacyPolicy,
    required TResult Function() supportedBrowsersAndOperatingSystems,
    required TResult Function() unknown,
  }) {
    return termsOfService();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? termsOfService,
    TResult? Function()? privacyPolicy,
    TResult? Function()? supportedBrowsersAndOperatingSystems,
    TResult? Function()? unknown,
  }) {
    return termsOfService?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? termsOfService,
    TResult Function()? privacyPolicy,
    TResult Function()? supportedBrowsersAndOperatingSystems,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (termsOfService != null) {
      return termsOfService();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TermsOfService value) termsOfService,
    required TResult Function(_PrivacyPolicy value) privacyPolicy,
    required TResult Function(_SupportedBrowsers value)
        supportedBrowsersAndOperatingSystems,
    required TResult Function(_Unknown value) unknown,
  }) {
    return termsOfService(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TermsOfService value)? termsOfService,
    TResult? Function(_PrivacyPolicy value)? privacyPolicy,
    TResult? Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult? Function(_Unknown value)? unknown,
  }) {
    return termsOfService?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TermsOfService value)? termsOfService,
    TResult Function(_PrivacyPolicy value)? privacyPolicy,
    TResult Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult Function(_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (termsOfService != null) {
      return termsOfService(this);
    }
    return orElse();
  }
}

abstract class _TermsOfService implements LegalDocumentType {
  const factory _TermsOfService() = _$TermsOfServiceImpl;
}

/// @nodoc
abstract class _$$PrivacyPolicyImplCopyWith<$Res> {
  factory _$$PrivacyPolicyImplCopyWith(
          _$PrivacyPolicyImpl value, $Res Function(_$PrivacyPolicyImpl) then) =
      __$$PrivacyPolicyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PrivacyPolicyImplCopyWithImpl<$Res>
    extends _$LegalDocumentTypeCopyWithImpl<$Res, _$PrivacyPolicyImpl>
    implements _$$PrivacyPolicyImplCopyWith<$Res> {
  __$$PrivacyPolicyImplCopyWithImpl(
      _$PrivacyPolicyImpl _value, $Res Function(_$PrivacyPolicyImpl) _then)
      : super(_value, _then);

  /// Create a copy of LegalDocumentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PrivacyPolicyImpl implements _PrivacyPolicy {
  const _$PrivacyPolicyImpl();

  @override
  String toString() {
    return 'LegalDocumentType.privacyPolicy()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PrivacyPolicyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() termsOfService,
    required TResult Function() privacyPolicy,
    required TResult Function() supportedBrowsersAndOperatingSystems,
    required TResult Function() unknown,
  }) {
    return privacyPolicy();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? termsOfService,
    TResult? Function()? privacyPolicy,
    TResult? Function()? supportedBrowsersAndOperatingSystems,
    TResult? Function()? unknown,
  }) {
    return privacyPolicy?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? termsOfService,
    TResult Function()? privacyPolicy,
    TResult Function()? supportedBrowsersAndOperatingSystems,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (privacyPolicy != null) {
      return privacyPolicy();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TermsOfService value) termsOfService,
    required TResult Function(_PrivacyPolicy value) privacyPolicy,
    required TResult Function(_SupportedBrowsers value)
        supportedBrowsersAndOperatingSystems,
    required TResult Function(_Unknown value) unknown,
  }) {
    return privacyPolicy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TermsOfService value)? termsOfService,
    TResult? Function(_PrivacyPolicy value)? privacyPolicy,
    TResult? Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult? Function(_Unknown value)? unknown,
  }) {
    return privacyPolicy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TermsOfService value)? termsOfService,
    TResult Function(_PrivacyPolicy value)? privacyPolicy,
    TResult Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult Function(_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (privacyPolicy != null) {
      return privacyPolicy(this);
    }
    return orElse();
  }
}

abstract class _PrivacyPolicy implements LegalDocumentType {
  const factory _PrivacyPolicy() = _$PrivacyPolicyImpl;
}

/// @nodoc
abstract class _$$SupportedBrowsersImplCopyWith<$Res> {
  factory _$$SupportedBrowsersImplCopyWith(_$SupportedBrowsersImpl value,
          $Res Function(_$SupportedBrowsersImpl) then) =
      __$$SupportedBrowsersImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SupportedBrowsersImplCopyWithImpl<$Res>
    extends _$LegalDocumentTypeCopyWithImpl<$Res, _$SupportedBrowsersImpl>
    implements _$$SupportedBrowsersImplCopyWith<$Res> {
  __$$SupportedBrowsersImplCopyWithImpl(_$SupportedBrowsersImpl _value,
      $Res Function(_$SupportedBrowsersImpl) _then)
      : super(_value, _then);

  /// Create a copy of LegalDocumentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SupportedBrowsersImpl implements _SupportedBrowsers {
  const _$SupportedBrowsersImpl();

  @override
  String toString() {
    return 'LegalDocumentType.supportedBrowsersAndOperatingSystems()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SupportedBrowsersImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() termsOfService,
    required TResult Function() privacyPolicy,
    required TResult Function() supportedBrowsersAndOperatingSystems,
    required TResult Function() unknown,
  }) {
    return supportedBrowsersAndOperatingSystems();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? termsOfService,
    TResult? Function()? privacyPolicy,
    TResult? Function()? supportedBrowsersAndOperatingSystems,
    TResult? Function()? unknown,
  }) {
    return supportedBrowsersAndOperatingSystems?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? termsOfService,
    TResult Function()? privacyPolicy,
    TResult Function()? supportedBrowsersAndOperatingSystems,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (supportedBrowsersAndOperatingSystems != null) {
      return supportedBrowsersAndOperatingSystems();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TermsOfService value) termsOfService,
    required TResult Function(_PrivacyPolicy value) privacyPolicy,
    required TResult Function(_SupportedBrowsers value)
        supportedBrowsersAndOperatingSystems,
    required TResult Function(_Unknown value) unknown,
  }) {
    return supportedBrowsersAndOperatingSystems(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TermsOfService value)? termsOfService,
    TResult? Function(_PrivacyPolicy value)? privacyPolicy,
    TResult? Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult? Function(_Unknown value)? unknown,
  }) {
    return supportedBrowsersAndOperatingSystems?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TermsOfService value)? termsOfService,
    TResult Function(_PrivacyPolicy value)? privacyPolicy,
    TResult Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult Function(_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (supportedBrowsersAndOperatingSystems != null) {
      return supportedBrowsersAndOperatingSystems(this);
    }
    return orElse();
  }
}

abstract class _SupportedBrowsers implements LegalDocumentType {
  const factory _SupportedBrowsers() = _$SupportedBrowsersImpl;
}

/// @nodoc
abstract class _$$UnknownImplCopyWith<$Res> {
  factory _$$UnknownImplCopyWith(
          _$UnknownImpl value, $Res Function(_$UnknownImpl) then) =
      __$$UnknownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownImplCopyWithImpl<$Res>
    extends _$LegalDocumentTypeCopyWithImpl<$Res, _$UnknownImpl>
    implements _$$UnknownImplCopyWith<$Res> {
  __$$UnknownImplCopyWithImpl(
      _$UnknownImpl _value, $Res Function(_$UnknownImpl) _then)
      : super(_value, _then);

  /// Create a copy of LegalDocumentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UnknownImpl implements _Unknown {
  const _$UnknownImpl();

  @override
  String toString() {
    return 'LegalDocumentType.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnknownImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() termsOfService,
    required TResult Function() privacyPolicy,
    required TResult Function() supportedBrowsersAndOperatingSystems,
    required TResult Function() unknown,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? termsOfService,
    TResult? Function()? privacyPolicy,
    TResult? Function()? supportedBrowsersAndOperatingSystems,
    TResult? Function()? unknown,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? termsOfService,
    TResult Function()? privacyPolicy,
    TResult Function()? supportedBrowsersAndOperatingSystems,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TermsOfService value) termsOfService,
    required TResult Function(_PrivacyPolicy value) privacyPolicy,
    required TResult Function(_SupportedBrowsers value)
        supportedBrowsersAndOperatingSystems,
    required TResult Function(_Unknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TermsOfService value)? termsOfService,
    TResult? Function(_PrivacyPolicy value)? privacyPolicy,
    TResult? Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult? Function(_Unknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TermsOfService value)? termsOfService,
    TResult Function(_PrivacyPolicy value)? privacyPolicy,
    TResult Function(_SupportedBrowsers value)?
        supportedBrowsersAndOperatingSystems,
    TResult Function(_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class _Unknown implements LegalDocumentType {
  const factory _Unknown() = _$UnknownImpl;
}

/// @nodoc
mixin _$PaymentMethodType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bank,
    required TResult Function() creditCard,
    required TResult Function() mobileWallet,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? bank,
    TResult? Function()? creditCard,
    TResult? Function()? mobileWallet,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bank,
    TResult Function()? creditCard,
    TResult Function()? mobileWallet,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Bank value) bank,
    required TResult Function(_PaymentCreditCard value) creditCard,
    required TResult Function(_MoblieWallet value) mobileWallet,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Bank value)? bank,
    TResult? Function(_PaymentCreditCard value)? creditCard,
    TResult? Function(_MoblieWallet value)? mobileWallet,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Bank value)? bank,
    TResult Function(_PaymentCreditCard value)? creditCard,
    TResult Function(_MoblieWallet value)? mobileWallet,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentMethodTypeCopyWith<$Res> {
  factory $PaymentMethodTypeCopyWith(
          PaymentMethodType value, $Res Function(PaymentMethodType) then) =
      _$PaymentMethodTypeCopyWithImpl<$Res, PaymentMethodType>;
}

/// @nodoc
class _$PaymentMethodTypeCopyWithImpl<$Res, $Val extends PaymentMethodType>
    implements $PaymentMethodTypeCopyWith<$Res> {
  _$PaymentMethodTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PaymentMethodType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$BankImplCopyWith<$Res> {
  factory _$$BankImplCopyWith(
          _$BankImpl value, $Res Function(_$BankImpl) then) =
      __$$BankImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BankImplCopyWithImpl<$Res>
    extends _$PaymentMethodTypeCopyWithImpl<$Res, _$BankImpl>
    implements _$$BankImplCopyWith<$Res> {
  __$$BankImplCopyWithImpl(_$BankImpl _value, $Res Function(_$BankImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentMethodType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BankImpl implements _Bank {
  const _$BankImpl();

  @override
  String toString() {
    return 'PaymentMethodType.bank()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BankImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bank,
    required TResult Function() creditCard,
    required TResult Function() mobileWallet,
  }) {
    return bank();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? bank,
    TResult? Function()? creditCard,
    TResult? Function()? mobileWallet,
  }) {
    return bank?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bank,
    TResult Function()? creditCard,
    TResult Function()? mobileWallet,
    required TResult orElse(),
  }) {
    if (bank != null) {
      return bank();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Bank value) bank,
    required TResult Function(_PaymentCreditCard value) creditCard,
    required TResult Function(_MoblieWallet value) mobileWallet,
  }) {
    return bank(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Bank value)? bank,
    TResult? Function(_PaymentCreditCard value)? creditCard,
    TResult? Function(_MoblieWallet value)? mobileWallet,
  }) {
    return bank?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Bank value)? bank,
    TResult Function(_PaymentCreditCard value)? creditCard,
    TResult Function(_MoblieWallet value)? mobileWallet,
    required TResult orElse(),
  }) {
    if (bank != null) {
      return bank(this);
    }
    return orElse();
  }
}

abstract class _Bank implements PaymentMethodType {
  const factory _Bank() = _$BankImpl;
}

/// @nodoc
abstract class _$$PaymentCreditCardImplCopyWith<$Res> {
  factory _$$PaymentCreditCardImplCopyWith(_$PaymentCreditCardImpl value,
          $Res Function(_$PaymentCreditCardImpl) then) =
      __$$PaymentCreditCardImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentCreditCardImplCopyWithImpl<$Res>
    extends _$PaymentMethodTypeCopyWithImpl<$Res, _$PaymentCreditCardImpl>
    implements _$$PaymentCreditCardImplCopyWith<$Res> {
  __$$PaymentCreditCardImplCopyWithImpl(_$PaymentCreditCardImpl _value,
      $Res Function(_$PaymentCreditCardImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentMethodType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PaymentCreditCardImpl implements _PaymentCreditCard {
  const _$PaymentCreditCardImpl();

  @override
  String toString() {
    return 'PaymentMethodType.creditCard()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentCreditCardImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bank,
    required TResult Function() creditCard,
    required TResult Function() mobileWallet,
  }) {
    return creditCard();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? bank,
    TResult? Function()? creditCard,
    TResult? Function()? mobileWallet,
  }) {
    return creditCard?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bank,
    TResult Function()? creditCard,
    TResult Function()? mobileWallet,
    required TResult orElse(),
  }) {
    if (creditCard != null) {
      return creditCard();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Bank value) bank,
    required TResult Function(_PaymentCreditCard value) creditCard,
    required TResult Function(_MoblieWallet value) mobileWallet,
  }) {
    return creditCard(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Bank value)? bank,
    TResult? Function(_PaymentCreditCard value)? creditCard,
    TResult? Function(_MoblieWallet value)? mobileWallet,
  }) {
    return creditCard?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Bank value)? bank,
    TResult Function(_PaymentCreditCard value)? creditCard,
    TResult Function(_MoblieWallet value)? mobileWallet,
    required TResult orElse(),
  }) {
    if (creditCard != null) {
      return creditCard(this);
    }
    return orElse();
  }
}

abstract class _PaymentCreditCard implements PaymentMethodType {
  const factory _PaymentCreditCard() = _$PaymentCreditCardImpl;
}

/// @nodoc
abstract class _$$MoblieWalletImplCopyWith<$Res> {
  factory _$$MoblieWalletImplCopyWith(
          _$MoblieWalletImpl value, $Res Function(_$MoblieWalletImpl) then) =
      __$$MoblieWalletImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MoblieWalletImplCopyWithImpl<$Res>
    extends _$PaymentMethodTypeCopyWithImpl<$Res, _$MoblieWalletImpl>
    implements _$$MoblieWalletImplCopyWith<$Res> {
  __$$MoblieWalletImplCopyWithImpl(
      _$MoblieWalletImpl _value, $Res Function(_$MoblieWalletImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentMethodType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$MoblieWalletImpl implements _MoblieWallet {
  const _$MoblieWalletImpl();

  @override
  String toString() {
    return 'PaymentMethodType.mobileWallet()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MoblieWalletImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bank,
    required TResult Function() creditCard,
    required TResult Function() mobileWallet,
  }) {
    return mobileWallet();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? bank,
    TResult? Function()? creditCard,
    TResult? Function()? mobileWallet,
  }) {
    return mobileWallet?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bank,
    TResult Function()? creditCard,
    TResult Function()? mobileWallet,
    required TResult orElse(),
  }) {
    if (mobileWallet != null) {
      return mobileWallet();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Bank value) bank,
    required TResult Function(_PaymentCreditCard value) creditCard,
    required TResult Function(_MoblieWallet value) mobileWallet,
  }) {
    return mobileWallet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Bank value)? bank,
    TResult? Function(_PaymentCreditCard value)? creditCard,
    TResult? Function(_MoblieWallet value)? mobileWallet,
  }) {
    return mobileWallet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Bank value)? bank,
    TResult Function(_PaymentCreditCard value)? creditCard,
    TResult Function(_MoblieWallet value)? mobileWallet,
    required TResult orElse(),
  }) {
    if (mobileWallet != null) {
      return mobileWallet(this);
    }
    return orElse();
  }
}

abstract class _MoblieWallet implements PaymentMethodType {
  const factory _MoblieWallet() = _$MoblieWalletImpl;
}

/// @nodoc
mixin _$PaymentProcessorType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentProcessorTypeCopyWith<$Res> {
  factory $PaymentProcessorTypeCopyWith(PaymentProcessorType value,
          $Res Function(PaymentProcessorType) then) =
      _$PaymentProcessorTypeCopyWithImpl<$Res, PaymentProcessorType>;
}

/// @nodoc
class _$PaymentProcessorTypeCopyWithImpl<$Res,
        $Val extends PaymentProcessorType>
    implements $PaymentProcessorTypeCopyWith<$Res> {
  _$PaymentProcessorTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$FundTechImplCopyWith<$Res> {
  factory _$$FundTechImplCopyWith(
          _$FundTechImpl value, $Res Function(_$FundTechImpl) then) =
      __$$FundTechImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FundTechImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$FundTechImpl>
    implements _$$FundTechImplCopyWith<$Res> {
  __$$FundTechImplCopyWithImpl(
      _$FundTechImpl _value, $Res Function(_$FundTechImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FundTechImpl implements _FundTech {
  const _$FundTechImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.fundTech()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FundTechImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return fundTech();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return fundTech?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (fundTech != null) {
      return fundTech();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return fundTech(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return fundTech?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (fundTech != null) {
      return fundTech(this);
    }
    return orElse();
  }
}

abstract class _FundTech implements PaymentProcessorType {
  const factory _FundTech() = _$FundTechImpl;
}

/// @nodoc
abstract class _$$PayNearMeImplCopyWith<$Res> {
  factory _$$PayNearMeImplCopyWith(
          _$PayNearMeImpl value, $Res Function(_$PayNearMeImpl) then) =
      __$$PayNearMeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PayNearMeImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$PayNearMeImpl>
    implements _$$PayNearMeImplCopyWith<$Res> {
  __$$PayNearMeImplCopyWithImpl(
      _$PayNearMeImpl _value, $Res Function(_$PayNearMeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PayNearMeImpl implements _PayNearMe {
  const _$PayNearMeImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.payNearMe()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PayNearMeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return payNearMe();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return payNearMe?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (payNearMe != null) {
      return payNearMe();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return payNearMe(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return payNearMe?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (payNearMe != null) {
      return payNearMe(this);
    }
    return orElse();
  }
}

abstract class _PayNearMe implements PaymentProcessorType {
  const factory _PayNearMe() = _$PayNearMeImpl;
}

/// @nodoc
abstract class _$$ZegoImplCopyWith<$Res> {
  factory _$$ZegoImplCopyWith(
          _$ZegoImpl value, $Res Function(_$ZegoImpl) then) =
      __$$ZegoImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ZegoImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$ZegoImpl>
    implements _$$ZegoImplCopyWith<$Res> {
  __$$ZegoImplCopyWithImpl(_$ZegoImpl _value, $Res Function(_$ZegoImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ZegoImpl implements _Zego {
  const _$ZegoImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.zego()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ZegoImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return zego();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return zego?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (zego != null) {
      return zego();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return zego(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return zego?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (zego != null) {
      return zego(this);
    }
    return orElse();
  }
}

abstract class _Zego implements PaymentProcessorType {
  const factory _Zego() = _$ZegoImpl;
}

/// @nodoc
abstract class _$$IntelliPayImplCopyWith<$Res> {
  factory _$$IntelliPayImplCopyWith(
          _$IntelliPayImpl value, $Res Function(_$IntelliPayImpl) then) =
      __$$IntelliPayImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$IntelliPayImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$IntelliPayImpl>
    implements _$$IntelliPayImplCopyWith<$Res> {
  __$$IntelliPayImplCopyWithImpl(
      _$IntelliPayImpl _value, $Res Function(_$IntelliPayImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$IntelliPayImpl implements _IntelliPay {
  const _$IntelliPayImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.intelliPay()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$IntelliPayImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return intelliPay();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return intelliPay?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (intelliPay != null) {
      return intelliPay();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return intelliPay(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return intelliPay?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (intelliPay != null) {
      return intelliPay(this);
    }
    return orElse();
  }
}

abstract class _IntelliPay implements PaymentProcessorType {
  const factory _IntelliPay() = _$IntelliPayImpl;
}

/// @nodoc
abstract class _$$RBCImplCopyWith<$Res> {
  factory _$$RBCImplCopyWith(_$RBCImpl value, $Res Function(_$RBCImpl) then) =
      __$$RBCImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RBCImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$RBCImpl>
    implements _$$RBCImplCopyWith<$Res> {
  __$$RBCImplCopyWithImpl(_$RBCImpl _value, $Res Function(_$RBCImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RBCImpl implements _RBC {
  const _$RBCImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.rbc()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RBCImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return rbc();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return rbc?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (rbc != null) {
      return rbc();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return rbc(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return rbc?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (rbc != null) {
      return rbc(this);
    }
    return orElse();
  }
}

abstract class _RBC implements PaymentProcessorType {
  const factory _RBC() = _$RBCImpl;
}

/// @nodoc
abstract class _$$UnknownPaymentProcessorTypeImplCopyWith<$Res> {
  factory _$$UnknownPaymentProcessorTypeImplCopyWith(
          _$UnknownPaymentProcessorTypeImpl value,
          $Res Function(_$UnknownPaymentProcessorTypeImpl) then) =
      __$$UnknownPaymentProcessorTypeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownPaymentProcessorTypeImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res,
        _$UnknownPaymentProcessorTypeImpl>
    implements _$$UnknownPaymentProcessorTypeImplCopyWith<$Res> {
  __$$UnknownPaymentProcessorTypeImplCopyWithImpl(
      _$UnknownPaymentProcessorTypeImpl _value,
      $Res Function(_$UnknownPaymentProcessorTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UnknownPaymentProcessorTypeImpl
    implements _UnknownPaymentProcessorType {
  const _$UnknownPaymentProcessorTypeImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnknownPaymentProcessorTypeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class _UnknownPaymentProcessorType implements PaymentProcessorType {
  const factory _UnknownPaymentProcessorType() =
      _$UnknownPaymentProcessorTypeImpl;
}

/// @nodoc
abstract class _$$MobileWalletImplCopyWith<$Res> {
  factory _$$MobileWalletImplCopyWith(
          _$MobileWalletImpl value, $Res Function(_$MobileWalletImpl) then) =
      __$$MobileWalletImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MobileWalletImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$MobileWalletImpl>
    implements _$$MobileWalletImplCopyWith<$Res> {
  __$$MobileWalletImplCopyWithImpl(
      _$MobileWalletImpl _value, $Res Function(_$MobileWalletImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$MobileWalletImpl implements _MobileWallet {
  const _$MobileWalletImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.mobileWallet()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MobileWalletImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return mobileWallet();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return mobileWallet?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (mobileWallet != null) {
      return mobileWallet();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return mobileWallet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return mobileWallet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (mobileWallet != null) {
      return mobileWallet(this);
    }
    return orElse();
  }
}

abstract class _MobileWallet implements PaymentProcessorType {
  const factory _MobileWallet() = _$MobileWalletImpl;
}

/// @nodoc
abstract class _$$FlexImplCopyWith<$Res> {
  factory _$$FlexImplCopyWith(
          _$FlexImpl value, $Res Function(_$FlexImpl) then) =
      __$$FlexImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FlexImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$FlexImpl>
    implements _$$FlexImplCopyWith<$Res> {
  __$$FlexImplCopyWithImpl(_$FlexImpl _value, $Res Function(_$FlexImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FlexImpl implements _Flex {
  const _$FlexImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.flex()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FlexImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return flex();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return flex?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (flex != null) {
      return flex();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return flex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return flex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (flex != null) {
      return flex(this);
    }
    return orElse();
  }
}

abstract class _Flex implements PaymentProcessorType {
  const factory _Flex() = _$FlexImpl;
}

/// @nodoc
abstract class _$$GooglePayImplCopyWith<$Res> {
  factory _$$GooglePayImplCopyWith(
          _$GooglePayImpl value, $Res Function(_$GooglePayImpl) then) =
      __$$GooglePayImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GooglePayImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$GooglePayImpl>
    implements _$$GooglePayImplCopyWith<$Res> {
  __$$GooglePayImplCopyWithImpl(
      _$GooglePayImpl _value, $Res Function(_$GooglePayImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GooglePayImpl implements _GooglePay {
  const _$GooglePayImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.googlePlay()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GooglePayImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return googlePlay();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return googlePlay?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (googlePlay != null) {
      return googlePlay();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return googlePlay(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return googlePlay?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (googlePlay != null) {
      return googlePlay(this);
    }
    return orElse();
  }
}

abstract class _GooglePay implements PaymentProcessorType {
  const factory _GooglePay() = _$GooglePayImpl;
}

/// @nodoc
abstract class _$$PayPalImplCopyWith<$Res> {
  factory _$$PayPalImplCopyWith(
          _$PayPalImpl value, $Res Function(_$PayPalImpl) then) =
      __$$PayPalImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PayPalImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$PayPalImpl>
    implements _$$PayPalImplCopyWith<$Res> {
  __$$PayPalImplCopyWithImpl(
      _$PayPalImpl _value, $Res Function(_$PayPalImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PayPalImpl implements _PayPal {
  const _$PayPalImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.payPal()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PayPalImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return payPal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return payPal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (payPal != null) {
      return payPal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return payPal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return payPal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (payPal != null) {
      return payPal(this);
    }
    return orElse();
  }
}

abstract class _PayPal implements PaymentProcessorType {
  const factory _PayPal() = _$PayPalImpl;
}

/// @nodoc
abstract class _$$VenmoImplCopyWith<$Res> {
  factory _$$VenmoImplCopyWith(
          _$VenmoImpl value, $Res Function(_$VenmoImpl) then) =
      __$$VenmoImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VenmoImplCopyWithImpl<$Res>
    extends _$PaymentProcessorTypeCopyWithImpl<$Res, _$VenmoImpl>
    implements _$$VenmoImplCopyWith<$Res> {
  __$$VenmoImplCopyWithImpl(
      _$VenmoImpl _value, $Res Function(_$VenmoImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentProcessorType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$VenmoImpl implements _Venmo {
  const _$VenmoImpl();

  @override
  String toString() {
    return 'PaymentProcessorType.venmo()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$VenmoImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fundTech,
    required TResult Function() payNearMe,
    required TResult Function() zego,
    required TResult Function() intelliPay,
    required TResult Function() rbc,
    required TResult Function() unknown,
    required TResult Function() mobileWallet,
    required TResult Function() flex,
    required TResult Function() googlePlay,
    required TResult Function() payPal,
    required TResult Function() venmo,
  }) {
    return venmo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fundTech,
    TResult? Function()? payNearMe,
    TResult? Function()? zego,
    TResult? Function()? intelliPay,
    TResult? Function()? rbc,
    TResult? Function()? unknown,
    TResult? Function()? mobileWallet,
    TResult? Function()? flex,
    TResult? Function()? googlePlay,
    TResult? Function()? payPal,
    TResult? Function()? venmo,
  }) {
    return venmo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fundTech,
    TResult Function()? payNearMe,
    TResult Function()? zego,
    TResult Function()? intelliPay,
    TResult Function()? rbc,
    TResult Function()? unknown,
    TResult Function()? mobileWallet,
    TResult Function()? flex,
    TResult Function()? googlePlay,
    TResult Function()? payPal,
    TResult Function()? venmo,
    required TResult orElse(),
  }) {
    if (venmo != null) {
      return venmo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FundTech value) fundTech,
    required TResult Function(_PayNearMe value) payNearMe,
    required TResult Function(_Zego value) zego,
    required TResult Function(_IntelliPay value) intelliPay,
    required TResult Function(_RBC value) rbc,
    required TResult Function(_UnknownPaymentProcessorType value) unknown,
    required TResult Function(_MobileWallet value) mobileWallet,
    required TResult Function(_Flex value) flex,
    required TResult Function(_GooglePay value) googlePlay,
    required TResult Function(_PayPal value) payPal,
    required TResult Function(_Venmo value) venmo,
  }) {
    return venmo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FundTech value)? fundTech,
    TResult? Function(_PayNearMe value)? payNearMe,
    TResult? Function(_Zego value)? zego,
    TResult? Function(_IntelliPay value)? intelliPay,
    TResult? Function(_RBC value)? rbc,
    TResult? Function(_UnknownPaymentProcessorType value)? unknown,
    TResult? Function(_MobileWallet value)? mobileWallet,
    TResult? Function(_Flex value)? flex,
    TResult? Function(_GooglePay value)? googlePlay,
    TResult? Function(_PayPal value)? payPal,
    TResult? Function(_Venmo value)? venmo,
  }) {
    return venmo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FundTech value)? fundTech,
    TResult Function(_PayNearMe value)? payNearMe,
    TResult Function(_Zego value)? zego,
    TResult Function(_IntelliPay value)? intelliPay,
    TResult Function(_RBC value)? rbc,
    TResult Function(_UnknownPaymentProcessorType value)? unknown,
    TResult Function(_MobileWallet value)? mobileWallet,
    TResult Function(_Flex value)? flex,
    TResult Function(_GooglePay value)? googlePlay,
    TResult Function(_PayPal value)? payPal,
    TResult Function(_Venmo value)? venmo,
    required TResult orElse(),
  }) {
    if (venmo != null) {
      return venmo(this);
    }
    return orElse();
  }
}

abstract class _Venmo implements PaymentProcessorType {
  const factory _Venmo() = _$VenmoImpl;
}

/// @nodoc
mixin _$PaymentType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() cash,
    required TResult Function() cashPay,
    required TResult Function() check,
    required TResult Function() creditCard,
    required TResult Function() electronicFundsTransfer,
    required TResult Function() moneyOrder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? cash,
    TResult? Function()? cashPay,
    TResult? Function()? check,
    TResult? Function()? creditCard,
    TResult? Function()? electronicFundsTransfer,
    TResult? Function()? moneyOrder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? cash,
    TResult Function()? cashPay,
    TResult Function()? check,
    TResult Function()? creditCard,
    TResult Function()? electronicFundsTransfer,
    TResult Function()? moneyOrder,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AutomatedClearingHouse value) rent,
    required TResult Function(_Cash value) cash,
    required TResult Function(_CashPay value) cashPay,
    required TResult Function(_Check value) check,
    required TResult Function(_CreditCard value) creditCard,
    required TResult Function(_ElectronicFundsTransfer value)
        electronicFundsTransfer,
    required TResult Function(_MoneyOrder value) moneyOrder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AutomatedClearingHouse value)? rent,
    TResult? Function(_Cash value)? cash,
    TResult? Function(_CashPay value)? cashPay,
    TResult? Function(_Check value)? check,
    TResult? Function(_CreditCard value)? creditCard,
    TResult? Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult? Function(_MoneyOrder value)? moneyOrder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AutomatedClearingHouse value)? rent,
    TResult Function(_Cash value)? cash,
    TResult Function(_CashPay value)? cashPay,
    TResult Function(_Check value)? check,
    TResult Function(_CreditCard value)? creditCard,
    TResult Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult Function(_MoneyOrder value)? moneyOrder,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentTypeCopyWith<$Res> {
  factory $PaymentTypeCopyWith(
          PaymentType value, $Res Function(PaymentType) then) =
      _$PaymentTypeCopyWithImpl<$Res, PaymentType>;
}

/// @nodoc
class _$PaymentTypeCopyWithImpl<$Res, $Val extends PaymentType>
    implements $PaymentTypeCopyWith<$Res> {
  _$PaymentTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PaymentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$AutomatedClearingHouseImplCopyWith<$Res> {
  factory _$$AutomatedClearingHouseImplCopyWith(
          _$AutomatedClearingHouseImpl value,
          $Res Function(_$AutomatedClearingHouseImpl) then) =
      __$$AutomatedClearingHouseImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AutomatedClearingHouseImplCopyWithImpl<$Res>
    extends _$PaymentTypeCopyWithImpl<$Res, _$AutomatedClearingHouseImpl>
    implements _$$AutomatedClearingHouseImplCopyWith<$Res> {
  __$$AutomatedClearingHouseImplCopyWithImpl(
      _$AutomatedClearingHouseImpl _value,
      $Res Function(_$AutomatedClearingHouseImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AutomatedClearingHouseImpl implements _AutomatedClearingHouse {
  const _$AutomatedClearingHouseImpl();

  @override
  String toString() {
    return 'PaymentType.rent()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AutomatedClearingHouseImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() cash,
    required TResult Function() cashPay,
    required TResult Function() check,
    required TResult Function() creditCard,
    required TResult Function() electronicFundsTransfer,
    required TResult Function() moneyOrder,
  }) {
    return rent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? cash,
    TResult? Function()? cashPay,
    TResult? Function()? check,
    TResult? Function()? creditCard,
    TResult? Function()? electronicFundsTransfer,
    TResult? Function()? moneyOrder,
  }) {
    return rent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? cash,
    TResult Function()? cashPay,
    TResult Function()? check,
    TResult Function()? creditCard,
    TResult Function()? electronicFundsTransfer,
    TResult Function()? moneyOrder,
    required TResult orElse(),
  }) {
    if (rent != null) {
      return rent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AutomatedClearingHouse value) rent,
    required TResult Function(_Cash value) cash,
    required TResult Function(_CashPay value) cashPay,
    required TResult Function(_Check value) check,
    required TResult Function(_CreditCard value) creditCard,
    required TResult Function(_ElectronicFundsTransfer value)
        electronicFundsTransfer,
    required TResult Function(_MoneyOrder value) moneyOrder,
  }) {
    return rent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AutomatedClearingHouse value)? rent,
    TResult? Function(_Cash value)? cash,
    TResult? Function(_CashPay value)? cashPay,
    TResult? Function(_Check value)? check,
    TResult? Function(_CreditCard value)? creditCard,
    TResult? Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult? Function(_MoneyOrder value)? moneyOrder,
  }) {
    return rent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AutomatedClearingHouse value)? rent,
    TResult Function(_Cash value)? cash,
    TResult Function(_CashPay value)? cashPay,
    TResult Function(_Check value)? check,
    TResult Function(_CreditCard value)? creditCard,
    TResult Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult Function(_MoneyOrder value)? moneyOrder,
    required TResult orElse(),
  }) {
    if (rent != null) {
      return rent(this);
    }
    return orElse();
  }
}

abstract class _AutomatedClearingHouse implements PaymentType {
  const factory _AutomatedClearingHouse() = _$AutomatedClearingHouseImpl;
}

/// @nodoc
abstract class _$$CashImplCopyWith<$Res> {
  factory _$$CashImplCopyWith(
          _$CashImpl value, $Res Function(_$CashImpl) then) =
      __$$CashImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CashImplCopyWithImpl<$Res>
    extends _$PaymentTypeCopyWithImpl<$Res, _$CashImpl>
    implements _$$CashImplCopyWith<$Res> {
  __$$CashImplCopyWithImpl(_$CashImpl _value, $Res Function(_$CashImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CashImpl implements _Cash {
  const _$CashImpl();

  @override
  String toString() {
    return 'PaymentType.cash()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CashImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() cash,
    required TResult Function() cashPay,
    required TResult Function() check,
    required TResult Function() creditCard,
    required TResult Function() electronicFundsTransfer,
    required TResult Function() moneyOrder,
  }) {
    return cash();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? cash,
    TResult? Function()? cashPay,
    TResult? Function()? check,
    TResult? Function()? creditCard,
    TResult? Function()? electronicFundsTransfer,
    TResult? Function()? moneyOrder,
  }) {
    return cash?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? cash,
    TResult Function()? cashPay,
    TResult Function()? check,
    TResult Function()? creditCard,
    TResult Function()? electronicFundsTransfer,
    TResult Function()? moneyOrder,
    required TResult orElse(),
  }) {
    if (cash != null) {
      return cash();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AutomatedClearingHouse value) rent,
    required TResult Function(_Cash value) cash,
    required TResult Function(_CashPay value) cashPay,
    required TResult Function(_Check value) check,
    required TResult Function(_CreditCard value) creditCard,
    required TResult Function(_ElectronicFundsTransfer value)
        electronicFundsTransfer,
    required TResult Function(_MoneyOrder value) moneyOrder,
  }) {
    return cash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AutomatedClearingHouse value)? rent,
    TResult? Function(_Cash value)? cash,
    TResult? Function(_CashPay value)? cashPay,
    TResult? Function(_Check value)? check,
    TResult? Function(_CreditCard value)? creditCard,
    TResult? Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult? Function(_MoneyOrder value)? moneyOrder,
  }) {
    return cash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AutomatedClearingHouse value)? rent,
    TResult Function(_Cash value)? cash,
    TResult Function(_CashPay value)? cashPay,
    TResult Function(_Check value)? check,
    TResult Function(_CreditCard value)? creditCard,
    TResult Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult Function(_MoneyOrder value)? moneyOrder,
    required TResult orElse(),
  }) {
    if (cash != null) {
      return cash(this);
    }
    return orElse();
  }
}

abstract class _Cash implements PaymentType {
  const factory _Cash() = _$CashImpl;
}

/// @nodoc
abstract class _$$CashPayImplCopyWith<$Res> {
  factory _$$CashPayImplCopyWith(
          _$CashPayImpl value, $Res Function(_$CashPayImpl) then) =
      __$$CashPayImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CashPayImplCopyWithImpl<$Res>
    extends _$PaymentTypeCopyWithImpl<$Res, _$CashPayImpl>
    implements _$$CashPayImplCopyWith<$Res> {
  __$$CashPayImplCopyWithImpl(
      _$CashPayImpl _value, $Res Function(_$CashPayImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CashPayImpl implements _CashPay {
  const _$CashPayImpl();

  @override
  String toString() {
    return 'PaymentType.cashPay()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CashPayImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() cash,
    required TResult Function() cashPay,
    required TResult Function() check,
    required TResult Function() creditCard,
    required TResult Function() electronicFundsTransfer,
    required TResult Function() moneyOrder,
  }) {
    return cashPay();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? cash,
    TResult? Function()? cashPay,
    TResult? Function()? check,
    TResult? Function()? creditCard,
    TResult? Function()? electronicFundsTransfer,
    TResult? Function()? moneyOrder,
  }) {
    return cashPay?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? cash,
    TResult Function()? cashPay,
    TResult Function()? check,
    TResult Function()? creditCard,
    TResult Function()? electronicFundsTransfer,
    TResult Function()? moneyOrder,
    required TResult orElse(),
  }) {
    if (cashPay != null) {
      return cashPay();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AutomatedClearingHouse value) rent,
    required TResult Function(_Cash value) cash,
    required TResult Function(_CashPay value) cashPay,
    required TResult Function(_Check value) check,
    required TResult Function(_CreditCard value) creditCard,
    required TResult Function(_ElectronicFundsTransfer value)
        electronicFundsTransfer,
    required TResult Function(_MoneyOrder value) moneyOrder,
  }) {
    return cashPay(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AutomatedClearingHouse value)? rent,
    TResult? Function(_Cash value)? cash,
    TResult? Function(_CashPay value)? cashPay,
    TResult? Function(_Check value)? check,
    TResult? Function(_CreditCard value)? creditCard,
    TResult? Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult? Function(_MoneyOrder value)? moneyOrder,
  }) {
    return cashPay?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AutomatedClearingHouse value)? rent,
    TResult Function(_Cash value)? cash,
    TResult Function(_CashPay value)? cashPay,
    TResult Function(_Check value)? check,
    TResult Function(_CreditCard value)? creditCard,
    TResult Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult Function(_MoneyOrder value)? moneyOrder,
    required TResult orElse(),
  }) {
    if (cashPay != null) {
      return cashPay(this);
    }
    return orElse();
  }
}

abstract class _CashPay implements PaymentType {
  const factory _CashPay() = _$CashPayImpl;
}

/// @nodoc
abstract class _$$CheckImplCopyWith<$Res> {
  factory _$$CheckImplCopyWith(
          _$CheckImpl value, $Res Function(_$CheckImpl) then) =
      __$$CheckImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CheckImplCopyWithImpl<$Res>
    extends _$PaymentTypeCopyWithImpl<$Res, _$CheckImpl>
    implements _$$CheckImplCopyWith<$Res> {
  __$$CheckImplCopyWithImpl(
      _$CheckImpl _value, $Res Function(_$CheckImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CheckImpl implements _Check {
  const _$CheckImpl();

  @override
  String toString() {
    return 'PaymentType.check()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CheckImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() cash,
    required TResult Function() cashPay,
    required TResult Function() check,
    required TResult Function() creditCard,
    required TResult Function() electronicFundsTransfer,
    required TResult Function() moneyOrder,
  }) {
    return check();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? cash,
    TResult? Function()? cashPay,
    TResult? Function()? check,
    TResult? Function()? creditCard,
    TResult? Function()? electronicFundsTransfer,
    TResult? Function()? moneyOrder,
  }) {
    return check?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? cash,
    TResult Function()? cashPay,
    TResult Function()? check,
    TResult Function()? creditCard,
    TResult Function()? electronicFundsTransfer,
    TResult Function()? moneyOrder,
    required TResult orElse(),
  }) {
    if (check != null) {
      return check();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AutomatedClearingHouse value) rent,
    required TResult Function(_Cash value) cash,
    required TResult Function(_CashPay value) cashPay,
    required TResult Function(_Check value) check,
    required TResult Function(_CreditCard value) creditCard,
    required TResult Function(_ElectronicFundsTransfer value)
        electronicFundsTransfer,
    required TResult Function(_MoneyOrder value) moneyOrder,
  }) {
    return check(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AutomatedClearingHouse value)? rent,
    TResult? Function(_Cash value)? cash,
    TResult? Function(_CashPay value)? cashPay,
    TResult? Function(_Check value)? check,
    TResult? Function(_CreditCard value)? creditCard,
    TResult? Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult? Function(_MoneyOrder value)? moneyOrder,
  }) {
    return check?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AutomatedClearingHouse value)? rent,
    TResult Function(_Cash value)? cash,
    TResult Function(_CashPay value)? cashPay,
    TResult Function(_Check value)? check,
    TResult Function(_CreditCard value)? creditCard,
    TResult Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult Function(_MoneyOrder value)? moneyOrder,
    required TResult orElse(),
  }) {
    if (check != null) {
      return check(this);
    }
    return orElse();
  }
}

abstract class _Check implements PaymentType {
  const factory _Check() = _$CheckImpl;
}

/// @nodoc
abstract class _$$CreditCardImplCopyWith<$Res> {
  factory _$$CreditCardImplCopyWith(
          _$CreditCardImpl value, $Res Function(_$CreditCardImpl) then) =
      __$$CreditCardImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CreditCardImplCopyWithImpl<$Res>
    extends _$PaymentTypeCopyWithImpl<$Res, _$CreditCardImpl>
    implements _$$CreditCardImplCopyWith<$Res> {
  __$$CreditCardImplCopyWithImpl(
      _$CreditCardImpl _value, $Res Function(_$CreditCardImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CreditCardImpl implements _CreditCard {
  const _$CreditCardImpl();

  @override
  String toString() {
    return 'PaymentType.creditCard()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CreditCardImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() cash,
    required TResult Function() cashPay,
    required TResult Function() check,
    required TResult Function() creditCard,
    required TResult Function() electronicFundsTransfer,
    required TResult Function() moneyOrder,
  }) {
    return creditCard();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? cash,
    TResult? Function()? cashPay,
    TResult? Function()? check,
    TResult? Function()? creditCard,
    TResult? Function()? electronicFundsTransfer,
    TResult? Function()? moneyOrder,
  }) {
    return creditCard?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? cash,
    TResult Function()? cashPay,
    TResult Function()? check,
    TResult Function()? creditCard,
    TResult Function()? electronicFundsTransfer,
    TResult Function()? moneyOrder,
    required TResult orElse(),
  }) {
    if (creditCard != null) {
      return creditCard();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AutomatedClearingHouse value) rent,
    required TResult Function(_Cash value) cash,
    required TResult Function(_CashPay value) cashPay,
    required TResult Function(_Check value) check,
    required TResult Function(_CreditCard value) creditCard,
    required TResult Function(_ElectronicFundsTransfer value)
        electronicFundsTransfer,
    required TResult Function(_MoneyOrder value) moneyOrder,
  }) {
    return creditCard(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AutomatedClearingHouse value)? rent,
    TResult? Function(_Cash value)? cash,
    TResult? Function(_CashPay value)? cashPay,
    TResult? Function(_Check value)? check,
    TResult? Function(_CreditCard value)? creditCard,
    TResult? Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult? Function(_MoneyOrder value)? moneyOrder,
  }) {
    return creditCard?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AutomatedClearingHouse value)? rent,
    TResult Function(_Cash value)? cash,
    TResult Function(_CashPay value)? cashPay,
    TResult Function(_Check value)? check,
    TResult Function(_CreditCard value)? creditCard,
    TResult Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult Function(_MoneyOrder value)? moneyOrder,
    required TResult orElse(),
  }) {
    if (creditCard != null) {
      return creditCard(this);
    }
    return orElse();
  }
}

abstract class _CreditCard implements PaymentType {
  const factory _CreditCard() = _$CreditCardImpl;
}

/// @nodoc
abstract class _$$ElectronicFundsTransferImplCopyWith<$Res> {
  factory _$$ElectronicFundsTransferImplCopyWith(
          _$ElectronicFundsTransferImpl value,
          $Res Function(_$ElectronicFundsTransferImpl) then) =
      __$$ElectronicFundsTransferImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ElectronicFundsTransferImplCopyWithImpl<$Res>
    extends _$PaymentTypeCopyWithImpl<$Res, _$ElectronicFundsTransferImpl>
    implements _$$ElectronicFundsTransferImplCopyWith<$Res> {
  __$$ElectronicFundsTransferImplCopyWithImpl(
      _$ElectronicFundsTransferImpl _value,
      $Res Function(_$ElectronicFundsTransferImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ElectronicFundsTransferImpl implements _ElectronicFundsTransfer {
  const _$ElectronicFundsTransferImpl();

  @override
  String toString() {
    return 'PaymentType.electronicFundsTransfer()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElectronicFundsTransferImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() cash,
    required TResult Function() cashPay,
    required TResult Function() check,
    required TResult Function() creditCard,
    required TResult Function() electronicFundsTransfer,
    required TResult Function() moneyOrder,
  }) {
    return electronicFundsTransfer();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? cash,
    TResult? Function()? cashPay,
    TResult? Function()? check,
    TResult? Function()? creditCard,
    TResult? Function()? electronicFundsTransfer,
    TResult? Function()? moneyOrder,
  }) {
    return electronicFundsTransfer?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? cash,
    TResult Function()? cashPay,
    TResult Function()? check,
    TResult Function()? creditCard,
    TResult Function()? electronicFundsTransfer,
    TResult Function()? moneyOrder,
    required TResult orElse(),
  }) {
    if (electronicFundsTransfer != null) {
      return electronicFundsTransfer();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AutomatedClearingHouse value) rent,
    required TResult Function(_Cash value) cash,
    required TResult Function(_CashPay value) cashPay,
    required TResult Function(_Check value) check,
    required TResult Function(_CreditCard value) creditCard,
    required TResult Function(_ElectronicFundsTransfer value)
        electronicFundsTransfer,
    required TResult Function(_MoneyOrder value) moneyOrder,
  }) {
    return electronicFundsTransfer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AutomatedClearingHouse value)? rent,
    TResult? Function(_Cash value)? cash,
    TResult? Function(_CashPay value)? cashPay,
    TResult? Function(_Check value)? check,
    TResult? Function(_CreditCard value)? creditCard,
    TResult? Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult? Function(_MoneyOrder value)? moneyOrder,
  }) {
    return electronicFundsTransfer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AutomatedClearingHouse value)? rent,
    TResult Function(_Cash value)? cash,
    TResult Function(_CashPay value)? cashPay,
    TResult Function(_Check value)? check,
    TResult Function(_CreditCard value)? creditCard,
    TResult Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult Function(_MoneyOrder value)? moneyOrder,
    required TResult orElse(),
  }) {
    if (electronicFundsTransfer != null) {
      return electronicFundsTransfer(this);
    }
    return orElse();
  }
}

abstract class _ElectronicFundsTransfer implements PaymentType {
  const factory _ElectronicFundsTransfer() = _$ElectronicFundsTransferImpl;
}

/// @nodoc
abstract class _$$MoneyOrderImplCopyWith<$Res> {
  factory _$$MoneyOrderImplCopyWith(
          _$MoneyOrderImpl value, $Res Function(_$MoneyOrderImpl) then) =
      __$$MoneyOrderImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MoneyOrderImplCopyWithImpl<$Res>
    extends _$PaymentTypeCopyWithImpl<$Res, _$MoneyOrderImpl>
    implements _$$MoneyOrderImplCopyWith<$Res> {
  __$$MoneyOrderImplCopyWithImpl(
      _$MoneyOrderImpl _value, $Res Function(_$MoneyOrderImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$MoneyOrderImpl implements _MoneyOrder {
  const _$MoneyOrderImpl();

  @override
  String toString() {
    return 'PaymentType.moneyOrder()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MoneyOrderImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() cash,
    required TResult Function() cashPay,
    required TResult Function() check,
    required TResult Function() creditCard,
    required TResult Function() electronicFundsTransfer,
    required TResult Function() moneyOrder,
  }) {
    return moneyOrder();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? cash,
    TResult? Function()? cashPay,
    TResult? Function()? check,
    TResult? Function()? creditCard,
    TResult? Function()? electronicFundsTransfer,
    TResult? Function()? moneyOrder,
  }) {
    return moneyOrder?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? cash,
    TResult Function()? cashPay,
    TResult Function()? check,
    TResult Function()? creditCard,
    TResult Function()? electronicFundsTransfer,
    TResult Function()? moneyOrder,
    required TResult orElse(),
  }) {
    if (moneyOrder != null) {
      return moneyOrder();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AutomatedClearingHouse value) rent,
    required TResult Function(_Cash value) cash,
    required TResult Function(_CashPay value) cashPay,
    required TResult Function(_Check value) check,
    required TResult Function(_CreditCard value) creditCard,
    required TResult Function(_ElectronicFundsTransfer value)
        electronicFundsTransfer,
    required TResult Function(_MoneyOrder value) moneyOrder,
  }) {
    return moneyOrder(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AutomatedClearingHouse value)? rent,
    TResult? Function(_Cash value)? cash,
    TResult? Function(_CashPay value)? cashPay,
    TResult? Function(_Check value)? check,
    TResult? Function(_CreditCard value)? creditCard,
    TResult? Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult? Function(_MoneyOrder value)? moneyOrder,
  }) {
    return moneyOrder?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AutomatedClearingHouse value)? rent,
    TResult Function(_Cash value)? cash,
    TResult Function(_CashPay value)? cashPay,
    TResult Function(_Check value)? check,
    TResult Function(_CreditCard value)? creditCard,
    TResult Function(_ElectronicFundsTransfer value)? electronicFundsTransfer,
    TResult Function(_MoneyOrder value)? moneyOrder,
    required TResult orElse(),
  }) {
    if (moneyOrder != null) {
      return moneyOrder(this);
    }
    return orElse();
  }
}

abstract class _MoneyOrder implements PaymentType {
  const factory _MoneyOrder() = _$MoneyOrderImpl;
}

/// @nodoc
mixin _$PayToType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() loan,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? loan,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? loan,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Rent value) rent,
    required TResult Function(_Loan value) loan,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Rent value)? rent,
    TResult? Function(_Loan value)? loan,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Rent value)? rent,
    TResult Function(_Loan value)? loan,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PayToTypeCopyWith<$Res> {
  factory $PayToTypeCopyWith(PayToType value, $Res Function(PayToType) then) =
      _$PayToTypeCopyWithImpl<$Res, PayToType>;
}

/// @nodoc
class _$PayToTypeCopyWithImpl<$Res, $Val extends PayToType>
    implements $PayToTypeCopyWith<$Res> {
  _$PayToTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PayToType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$RentImplCopyWith<$Res> {
  factory _$$RentImplCopyWith(
          _$RentImpl value, $Res Function(_$RentImpl) then) =
      __$$RentImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RentImplCopyWithImpl<$Res>
    extends _$PayToTypeCopyWithImpl<$Res, _$RentImpl>
    implements _$$RentImplCopyWith<$Res> {
  __$$RentImplCopyWithImpl(_$RentImpl _value, $Res Function(_$RentImpl) _then)
      : super(_value, _then);

  /// Create a copy of PayToType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$RentImpl implements _Rent {
  const _$RentImpl();

  @override
  String toString() {
    return 'PayToType.rent()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RentImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() loan,
  }) {
    return rent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? loan,
  }) {
    return rent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? loan,
    required TResult orElse(),
  }) {
    if (rent != null) {
      return rent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Rent value) rent,
    required TResult Function(_Loan value) loan,
  }) {
    return rent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Rent value)? rent,
    TResult? Function(_Loan value)? loan,
  }) {
    return rent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Rent value)? rent,
    TResult Function(_Loan value)? loan,
    required TResult orElse(),
  }) {
    if (rent != null) {
      return rent(this);
    }
    return orElse();
  }
}

abstract class _Rent implements PayToType {
  const factory _Rent() = _$RentImpl;
}

/// @nodoc
abstract class _$$LoanImplCopyWith<$Res> {
  factory _$$LoanImplCopyWith(
          _$LoanImpl value, $Res Function(_$LoanImpl) then) =
      __$$LoanImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoanImplCopyWithImpl<$Res>
    extends _$PayToTypeCopyWithImpl<$Res, _$LoanImpl>
    implements _$$LoanImplCopyWith<$Res> {
  __$$LoanImplCopyWithImpl(_$LoanImpl _value, $Res Function(_$LoanImpl) _then)
      : super(_value, _then);

  /// Create a copy of PayToType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoanImpl implements _Loan {
  const _$LoanImpl();

  @override
  String toString() {
    return 'PayToType.loan()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoanImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rent,
    required TResult Function() loan,
  }) {
    return loan();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rent,
    TResult? Function()? loan,
  }) {
    return loan?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rent,
    TResult Function()? loan,
    required TResult orElse(),
  }) {
    if (loan != null) {
      return loan();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Rent value) rent,
    required TResult Function(_Loan value) loan,
  }) {
    return loan(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Rent value)? rent,
    TResult? Function(_Loan value)? loan,
  }) {
    return loan?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Rent value)? rent,
    TResult Function(_Loan value)? loan,
    required TResult orElse(),
  }) {
    if (loan != null) {
      return loan(this);
    }
    return orElse();
  }
}

abstract class _Loan implements PayToType {
  const factory _Loan() = _$LoanImpl;
}

/// @nodoc
mixin _$LocaleType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() english,
    required TResult Function() spanish,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? english,
    TResult? Function()? spanish,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? english,
    TResult Function()? spanish,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_English value) english,
    required TResult Function(_Spanish value) spanish,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_English value)? english,
    TResult? Function(_Spanish value)? spanish,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_English value)? english,
    TResult Function(_Spanish value)? spanish,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocaleTypeCopyWith<$Res> {
  factory $LocaleTypeCopyWith(
          LocaleType value, $Res Function(LocaleType) then) =
      _$LocaleTypeCopyWithImpl<$Res, LocaleType>;
}

/// @nodoc
class _$LocaleTypeCopyWithImpl<$Res, $Val extends LocaleType>
    implements $LocaleTypeCopyWith<$Res> {
  _$LocaleTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LocaleType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$EnglishImplCopyWith<$Res> {
  factory _$$EnglishImplCopyWith(
          _$EnglishImpl value, $Res Function(_$EnglishImpl) then) =
      __$$EnglishImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EnglishImplCopyWithImpl<$Res>
    extends _$LocaleTypeCopyWithImpl<$Res, _$EnglishImpl>
    implements _$$EnglishImplCopyWith<$Res> {
  __$$EnglishImplCopyWithImpl(
      _$EnglishImpl _value, $Res Function(_$EnglishImpl) _then)
      : super(_value, _then);

  /// Create a copy of LocaleType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EnglishImpl implements _English {
  const _$EnglishImpl();

  @override
  String toString() {
    return 'LocaleType.english()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EnglishImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() english,
    required TResult Function() spanish,
  }) {
    return english();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? english,
    TResult? Function()? spanish,
  }) {
    return english?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? english,
    TResult Function()? spanish,
    required TResult orElse(),
  }) {
    if (english != null) {
      return english();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_English value) english,
    required TResult Function(_Spanish value) spanish,
  }) {
    return english(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_English value)? english,
    TResult? Function(_Spanish value)? spanish,
  }) {
    return english?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_English value)? english,
    TResult Function(_Spanish value)? spanish,
    required TResult orElse(),
  }) {
    if (english != null) {
      return english(this);
    }
    return orElse();
  }
}

abstract class _English implements LocaleType {
  const factory _English() = _$EnglishImpl;
}

/// @nodoc
abstract class _$$SpanishImplCopyWith<$Res> {
  factory _$$SpanishImplCopyWith(
          _$SpanishImpl value, $Res Function(_$SpanishImpl) then) =
      __$$SpanishImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SpanishImplCopyWithImpl<$Res>
    extends _$LocaleTypeCopyWithImpl<$Res, _$SpanishImpl>
    implements _$$SpanishImplCopyWith<$Res> {
  __$$SpanishImplCopyWithImpl(
      _$SpanishImpl _value, $Res Function(_$SpanishImpl) _then)
      : super(_value, _then);

  /// Create a copy of LocaleType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SpanishImpl implements _Spanish {
  const _$SpanishImpl();

  @override
  String toString() {
    return 'LocaleType.spanish()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SpanishImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() english,
    required TResult Function() spanish,
  }) {
    return spanish();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? english,
    TResult? Function()? spanish,
  }) {
    return spanish?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? english,
    TResult Function()? spanish,
    required TResult orElse(),
  }) {
    if (spanish != null) {
      return spanish();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_English value) english,
    required TResult Function(_Spanish value) spanish,
  }) {
    return spanish(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_English value)? english,
    TResult? Function(_Spanish value)? spanish,
  }) {
    return spanish?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_English value)? english,
    TResult Function(_Spanish value)? spanish,
    required TResult orElse(),
  }) {
    if (spanish != null) {
      return spanish(this);
    }
    return orElse();
  }
}

abstract class _Spanish implements LocaleType {
  const factory _Spanish() = _$SpanishImpl;
}

/// @nodoc
mixin _$MakePaymentErrorCode {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() paymentAmountError,
    required TResult Function() shortPaymentError,
    required TResult Function() paymentError,
    required TResult Function() previousPaymentAmountError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? paymentAmountError,
    TResult? Function()? shortPaymentError,
    TResult? Function()? paymentError,
    TResult? Function()? previousPaymentAmountError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? paymentAmountError,
    TResult Function()? shortPaymentError,
    TResult Function()? paymentError,
    TResult Function()? previousPaymentAmountError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownMakePaymentErrorCode value) unknown,
    required TResult Function(_PaymentAmountError value) paymentAmountError,
    required TResult Function(_ShortPaymentError value) shortPaymentError,
    required TResult Function(_PaymentError value) paymentError,
    required TResult Function(_PreviousPaymentAmountError value)
        previousPaymentAmountError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult? Function(_PaymentAmountError value)? paymentAmountError,
    TResult? Function(_ShortPaymentError value)? shortPaymentError,
    TResult? Function(_PaymentError value)? paymentError,
    TResult? Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult Function(_PaymentAmountError value)? paymentAmountError,
    TResult Function(_ShortPaymentError value)? shortPaymentError,
    TResult Function(_PaymentError value)? paymentError,
    TResult Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MakePaymentErrorCodeCopyWith<$Res> {
  factory $MakePaymentErrorCodeCopyWith(MakePaymentErrorCode value,
          $Res Function(MakePaymentErrorCode) then) =
      _$MakePaymentErrorCodeCopyWithImpl<$Res, MakePaymentErrorCode>;
}

/// @nodoc
class _$MakePaymentErrorCodeCopyWithImpl<$Res,
        $Val extends MakePaymentErrorCode>
    implements $MakePaymentErrorCodeCopyWith<$Res> {
  _$MakePaymentErrorCodeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MakePaymentErrorCode
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$UnknownMakePaymentErrorCodeImplCopyWith<$Res> {
  factory _$$UnknownMakePaymentErrorCodeImplCopyWith(
          _$UnknownMakePaymentErrorCodeImpl value,
          $Res Function(_$UnknownMakePaymentErrorCodeImpl) then) =
      __$$UnknownMakePaymentErrorCodeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownMakePaymentErrorCodeImplCopyWithImpl<$Res>
    extends _$MakePaymentErrorCodeCopyWithImpl<$Res,
        _$UnknownMakePaymentErrorCodeImpl>
    implements _$$UnknownMakePaymentErrorCodeImplCopyWith<$Res> {
  __$$UnknownMakePaymentErrorCodeImplCopyWithImpl(
      _$UnknownMakePaymentErrorCodeImpl _value,
      $Res Function(_$UnknownMakePaymentErrorCodeImpl) _then)
      : super(_value, _then);

  /// Create a copy of MakePaymentErrorCode
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UnknownMakePaymentErrorCodeImpl
    implements _UnknownMakePaymentErrorCode {
  const _$UnknownMakePaymentErrorCodeImpl();

  @override
  String toString() {
    return 'MakePaymentErrorCode.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnknownMakePaymentErrorCodeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() paymentAmountError,
    required TResult Function() shortPaymentError,
    required TResult Function() paymentError,
    required TResult Function() previousPaymentAmountError,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? paymentAmountError,
    TResult? Function()? shortPaymentError,
    TResult? Function()? paymentError,
    TResult? Function()? previousPaymentAmountError,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? paymentAmountError,
    TResult Function()? shortPaymentError,
    TResult Function()? paymentError,
    TResult Function()? previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownMakePaymentErrorCode value) unknown,
    required TResult Function(_PaymentAmountError value) paymentAmountError,
    required TResult Function(_ShortPaymentError value) shortPaymentError,
    required TResult Function(_PaymentError value) paymentError,
    required TResult Function(_PreviousPaymentAmountError value)
        previousPaymentAmountError,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult? Function(_PaymentAmountError value)? paymentAmountError,
    TResult? Function(_ShortPaymentError value)? shortPaymentError,
    TResult? Function(_PaymentError value)? paymentError,
    TResult? Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult Function(_PaymentAmountError value)? paymentAmountError,
    TResult Function(_ShortPaymentError value)? shortPaymentError,
    TResult Function(_PaymentError value)? paymentError,
    TResult Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class _UnknownMakePaymentErrorCode implements MakePaymentErrorCode {
  const factory _UnknownMakePaymentErrorCode() =
      _$UnknownMakePaymentErrorCodeImpl;
}

/// @nodoc
abstract class _$$PaymentAmountErrorImplCopyWith<$Res> {
  factory _$$PaymentAmountErrorImplCopyWith(_$PaymentAmountErrorImpl value,
          $Res Function(_$PaymentAmountErrorImpl) then) =
      __$$PaymentAmountErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentAmountErrorImplCopyWithImpl<$Res>
    extends _$MakePaymentErrorCodeCopyWithImpl<$Res, _$PaymentAmountErrorImpl>
    implements _$$PaymentAmountErrorImplCopyWith<$Res> {
  __$$PaymentAmountErrorImplCopyWithImpl(_$PaymentAmountErrorImpl _value,
      $Res Function(_$PaymentAmountErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of MakePaymentErrorCode
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PaymentAmountErrorImpl implements _PaymentAmountError {
  const _$PaymentAmountErrorImpl();

  @override
  String toString() {
    return 'MakePaymentErrorCode.paymentAmountError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentAmountErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() paymentAmountError,
    required TResult Function() shortPaymentError,
    required TResult Function() paymentError,
    required TResult Function() previousPaymentAmountError,
  }) {
    return paymentAmountError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? paymentAmountError,
    TResult? Function()? shortPaymentError,
    TResult? Function()? paymentError,
    TResult? Function()? previousPaymentAmountError,
  }) {
    return paymentAmountError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? paymentAmountError,
    TResult Function()? shortPaymentError,
    TResult Function()? paymentError,
    TResult Function()? previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (paymentAmountError != null) {
      return paymentAmountError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownMakePaymentErrorCode value) unknown,
    required TResult Function(_PaymentAmountError value) paymentAmountError,
    required TResult Function(_ShortPaymentError value) shortPaymentError,
    required TResult Function(_PaymentError value) paymentError,
    required TResult Function(_PreviousPaymentAmountError value)
        previousPaymentAmountError,
  }) {
    return paymentAmountError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult? Function(_PaymentAmountError value)? paymentAmountError,
    TResult? Function(_ShortPaymentError value)? shortPaymentError,
    TResult? Function(_PaymentError value)? paymentError,
    TResult? Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
  }) {
    return paymentAmountError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult Function(_PaymentAmountError value)? paymentAmountError,
    TResult Function(_ShortPaymentError value)? shortPaymentError,
    TResult Function(_PaymentError value)? paymentError,
    TResult Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (paymentAmountError != null) {
      return paymentAmountError(this);
    }
    return orElse();
  }
}

abstract class _PaymentAmountError implements MakePaymentErrorCode {
  const factory _PaymentAmountError() = _$PaymentAmountErrorImpl;
}

/// @nodoc
abstract class _$$ShortPaymentErrorImplCopyWith<$Res> {
  factory _$$ShortPaymentErrorImplCopyWith(_$ShortPaymentErrorImpl value,
          $Res Function(_$ShortPaymentErrorImpl) then) =
      __$$ShortPaymentErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ShortPaymentErrorImplCopyWithImpl<$Res>
    extends _$MakePaymentErrorCodeCopyWithImpl<$Res, _$ShortPaymentErrorImpl>
    implements _$$ShortPaymentErrorImplCopyWith<$Res> {
  __$$ShortPaymentErrorImplCopyWithImpl(_$ShortPaymentErrorImpl _value,
      $Res Function(_$ShortPaymentErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of MakePaymentErrorCode
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ShortPaymentErrorImpl implements _ShortPaymentError {
  const _$ShortPaymentErrorImpl();

  @override
  String toString() {
    return 'MakePaymentErrorCode.shortPaymentError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ShortPaymentErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() paymentAmountError,
    required TResult Function() shortPaymentError,
    required TResult Function() paymentError,
    required TResult Function() previousPaymentAmountError,
  }) {
    return shortPaymentError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? paymentAmountError,
    TResult? Function()? shortPaymentError,
    TResult? Function()? paymentError,
    TResult? Function()? previousPaymentAmountError,
  }) {
    return shortPaymentError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? paymentAmountError,
    TResult Function()? shortPaymentError,
    TResult Function()? paymentError,
    TResult Function()? previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (shortPaymentError != null) {
      return shortPaymentError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownMakePaymentErrorCode value) unknown,
    required TResult Function(_PaymentAmountError value) paymentAmountError,
    required TResult Function(_ShortPaymentError value) shortPaymentError,
    required TResult Function(_PaymentError value) paymentError,
    required TResult Function(_PreviousPaymentAmountError value)
        previousPaymentAmountError,
  }) {
    return shortPaymentError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult? Function(_PaymentAmountError value)? paymentAmountError,
    TResult? Function(_ShortPaymentError value)? shortPaymentError,
    TResult? Function(_PaymentError value)? paymentError,
    TResult? Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
  }) {
    return shortPaymentError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult Function(_PaymentAmountError value)? paymentAmountError,
    TResult Function(_ShortPaymentError value)? shortPaymentError,
    TResult Function(_PaymentError value)? paymentError,
    TResult Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (shortPaymentError != null) {
      return shortPaymentError(this);
    }
    return orElse();
  }
}

abstract class _ShortPaymentError implements MakePaymentErrorCode {
  const factory _ShortPaymentError() = _$ShortPaymentErrorImpl;
}

/// @nodoc
abstract class _$$PaymentErrorImplCopyWith<$Res> {
  factory _$$PaymentErrorImplCopyWith(
          _$PaymentErrorImpl value, $Res Function(_$PaymentErrorImpl) then) =
      __$$PaymentErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentErrorImplCopyWithImpl<$Res>
    extends _$MakePaymentErrorCodeCopyWithImpl<$Res, _$PaymentErrorImpl>
    implements _$$PaymentErrorImplCopyWith<$Res> {
  __$$PaymentErrorImplCopyWithImpl(
      _$PaymentErrorImpl _value, $Res Function(_$PaymentErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of MakePaymentErrorCode
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PaymentErrorImpl implements _PaymentError {
  const _$PaymentErrorImpl();

  @override
  String toString() {
    return 'MakePaymentErrorCode.paymentError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() paymentAmountError,
    required TResult Function() shortPaymentError,
    required TResult Function() paymentError,
    required TResult Function() previousPaymentAmountError,
  }) {
    return paymentError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? paymentAmountError,
    TResult? Function()? shortPaymentError,
    TResult? Function()? paymentError,
    TResult? Function()? previousPaymentAmountError,
  }) {
    return paymentError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? paymentAmountError,
    TResult Function()? shortPaymentError,
    TResult Function()? paymentError,
    TResult Function()? previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (paymentError != null) {
      return paymentError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownMakePaymentErrorCode value) unknown,
    required TResult Function(_PaymentAmountError value) paymentAmountError,
    required TResult Function(_ShortPaymentError value) shortPaymentError,
    required TResult Function(_PaymentError value) paymentError,
    required TResult Function(_PreviousPaymentAmountError value)
        previousPaymentAmountError,
  }) {
    return paymentError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult? Function(_PaymentAmountError value)? paymentAmountError,
    TResult? Function(_ShortPaymentError value)? shortPaymentError,
    TResult? Function(_PaymentError value)? paymentError,
    TResult? Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
  }) {
    return paymentError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult Function(_PaymentAmountError value)? paymentAmountError,
    TResult Function(_ShortPaymentError value)? shortPaymentError,
    TResult Function(_PaymentError value)? paymentError,
    TResult Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (paymentError != null) {
      return paymentError(this);
    }
    return orElse();
  }
}

abstract class _PaymentError implements MakePaymentErrorCode {
  const factory _PaymentError() = _$PaymentErrorImpl;
}

/// @nodoc
abstract class _$$PreviousPaymentAmountErrorImplCopyWith<$Res> {
  factory _$$PreviousPaymentAmountErrorImplCopyWith(
          _$PreviousPaymentAmountErrorImpl value,
          $Res Function(_$PreviousPaymentAmountErrorImpl) then) =
      __$$PreviousPaymentAmountErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PreviousPaymentAmountErrorImplCopyWithImpl<$Res>
    extends _$MakePaymentErrorCodeCopyWithImpl<$Res,
        _$PreviousPaymentAmountErrorImpl>
    implements _$$PreviousPaymentAmountErrorImplCopyWith<$Res> {
  __$$PreviousPaymentAmountErrorImplCopyWithImpl(
      _$PreviousPaymentAmountErrorImpl _value,
      $Res Function(_$PreviousPaymentAmountErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of MakePaymentErrorCode
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PreviousPaymentAmountErrorImpl implements _PreviousPaymentAmountError {
  const _$PreviousPaymentAmountErrorImpl();

  @override
  String toString() {
    return 'MakePaymentErrorCode.previousPaymentAmountError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PreviousPaymentAmountErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function() paymentAmountError,
    required TResult Function() shortPaymentError,
    required TResult Function() paymentError,
    required TResult Function() previousPaymentAmountError,
  }) {
    return previousPaymentAmountError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function()? paymentAmountError,
    TResult? Function()? shortPaymentError,
    TResult? Function()? paymentError,
    TResult? Function()? previousPaymentAmountError,
  }) {
    return previousPaymentAmountError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function()? paymentAmountError,
    TResult Function()? shortPaymentError,
    TResult Function()? paymentError,
    TResult Function()? previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (previousPaymentAmountError != null) {
      return previousPaymentAmountError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnknownMakePaymentErrorCode value) unknown,
    required TResult Function(_PaymentAmountError value) paymentAmountError,
    required TResult Function(_ShortPaymentError value) shortPaymentError,
    required TResult Function(_PaymentError value) paymentError,
    required TResult Function(_PreviousPaymentAmountError value)
        previousPaymentAmountError,
  }) {
    return previousPaymentAmountError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult? Function(_PaymentAmountError value)? paymentAmountError,
    TResult? Function(_ShortPaymentError value)? shortPaymentError,
    TResult? Function(_PaymentError value)? paymentError,
    TResult? Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
  }) {
    return previousPaymentAmountError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnknownMakePaymentErrorCode value)? unknown,
    TResult Function(_PaymentAmountError value)? paymentAmountError,
    TResult Function(_ShortPaymentError value)? shortPaymentError,
    TResult Function(_PaymentError value)? paymentError,
    TResult Function(_PreviousPaymentAmountError value)?
        previousPaymentAmountError,
    required TResult orElse(),
  }) {
    if (previousPaymentAmountError != null) {
      return previousPaymentAmountError(this);
    }
    return orElse();
  }
}

abstract class _PreviousPaymentAmountError implements MakePaymentErrorCode {
  const factory _PreviousPaymentAmountError() =
      _$PreviousPaymentAmountErrorImpl;
}
